<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>specless.automaton.pdfa.PDFA &#8212; specless 0.0.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=e3a6060d"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="specless.automaton.pdfa.PDFABuilder" href="specless.automaton.pdfa.PDFABuilder.html" />
    <link rel="prev" title="specless.automaton.pdfa.check_predict_method" href="specless.automaton.pdfa.check_predict_method.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="specless-automaton-pdfa-pdfa">
<h1>specless.automaton.pdfa.PDFA<a class="headerlink" href="#specless-automaton-pdfa-pdfa" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">specless.automaton.pdfa.</span></span><span class="sig-name descname"><span class="pre">PDFA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NXNodeList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">NXEdgeList</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_display_map</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bidict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_transitions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_amount</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_transition_sym</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">{Symbol,</span> <span class="pre">None}</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">empty_transition_sym</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">{Symbol,</span> <span class="pre">None}</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_sinks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_normalized</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="specless.automaton.base.Automaton.html#specless.automaton.base.Automaton" title="specless.automaton.base.Automaton"><code class="xref py py-class docutils literal notranslate"><span class="pre">Automaton</span></code></a></p>
<p>This class describes a probabilistic deterministic finite automaton (pdfa).</p>
<p>built on networkx, so inherits node and edge data structure definitions</p>
<p>inherits some of its api from the NLTK LM API</p>
<section id="node-attributes">
<h2>Node Attributes<a class="headerlink" href="#node-attributes" title="Link to this heading">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>final_probability: final state probability for the node</p></li>
<li><p>trans_distribution: a sampled-able function to select the next state
and emitted symbol</p></li>
<li><p>is_accepting: a boolean flag determining whether the pdfa considers
the node accepting</p></li>
</ul>
</div></blockquote>
</section>
<section id="edge-properties">
<h2>Edge Properties<a class="headerlink" href="#edge-properties" title="Link to this heading">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>symbol: the symbol value emitted when the edge is traversed</p></li>
<li><p>probability: the probability of selecting this edge for traversal</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param      nodes<span class="colon">:</span></dt>
<dd class="field-odd"><p>node list as expected by
networkx.add_nodes_from() list of
tuples: (node label, node, attribute
dict)</p>
</dd>
<dt class="field-even">param      edges<span class="colon">:</span></dt>
<dd class="field-even"><p>edge list as expected by
networkx.add_edges_from() list of
tuples: (src node label, dest node
label, edge attribute dict)</p>
</dd>
<dt class="field-odd">param      symbol_display_map<span class="colon">:</span></dt>
<dd class="field-odd"><p>bidirectional mapping of hashable
symbols, to a unique integer index
in the symbol map. Needed to
translate between the indices in the
transition distribution and the
hashable representation which is
meaningful to the user</p>
</dd>
<dt class="field-even">param      alphabet_size<span class="colon">:</span></dt>
<dd class="field-even"><p>number of symbols in pdfa alphabet</p>
</dd>
<dt class="field-odd">param      num_states<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of states in automaton state
space</p>
</dd>
<dt class="field-even">param      start_state<span class="colon">:</span></dt>
<dd class="field-even"><p>unique start state string label of
pdfa</p>
</dd>
<dt class="field-odd">param      smooth_transitions<span class="colon">:</span></dt>
<dd class="field-odd"><p>whether to smooth the symbol
transitions distributions</p>
</dd>
<dt class="field-even">param      smoothing_amount<span class="colon">:</span></dt>
<dd class="field-even"><p>probability mass to re-assign to
unseen symbols at each node</p>
</dd>
<dt class="field-odd">param      final_transition_sym<span class="colon">:</span></dt>
<dd class="field-odd"><p>representation of the termination
symbol. If not given, will default
to base class default.</p>
</dd>
<dt class="field-even">param      empty_transition_sym<span class="colon">:</span></dt>
<dd class="field-even"><p>representation of the empty symbol
(a.k.a. lambda). If not given, will
default to base class default.</p>
</dd>
<dt class="field-odd">param      beta<span class="colon">:</span></dt>
<dd class="field-odd"><p>the final state probability needed
for a state to accept.</p>
</dd>
<dt class="field-even">param      merge_sinks<span class="colon">:</span></dt>
<dd class="field-even"><p>whether to combine all states
together that have no outgoing
edges</p>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edge" title="specless.automaton.pdfa.PDFA.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></p></td>
<td><p>Add an edge between u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="specless.automaton.pdfa.PDFA.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></p></td>
<td><p>Add all the edges in ebunch_to_add.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_node" title="specless.automaton.pdfa.PDFA.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code></a></p></td>
<td><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_nodes_from" title="specless.automaton.pdfa.PDFA.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_weighted_edges_from" title="specless.automaton.pdfa.PDFA.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></a></p></td>
<td><p>Add weighted edges in <cite>ebunch_to_add</cite> with specified weight attr</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adjacency" title="specless.automaton.pdfa.PDFA.adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacency</span></code></a></p></td>
<td><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.average_norm" title="specless.automaton.pdfa.PDFA.average_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_norm</span></code></a></p></td>
<td><p>computes Ln Norm (default n=2)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.clear" title="specless.automaton.pdfa.PDFA.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a></p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.clear_edges" title="specless.automaton.pdfa.PDFA.clear_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_edges</span></code></a></p></td>
<td><p>Remove all edges from the graph without altering nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.copy" title="specless.automaton.pdfa.PDFA.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a></p></td>
<td><p>Returns a copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.cross_entropy" title="specless.automaton.pdfa.PDFA.cross_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_entropy</span></code></a></p></td>
<td><p>computes actual cross-entropy of the given traces in the language of the PDFA on the given actual trace probabilities</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.cross_entropy_approx" title="specless.automaton.pdfa.PDFA.cross_entropy_approx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cross_entropy_approx</span></code></a></p></td>
<td><p>computes approximate cross-entropy of the given trace in the language of the PDFA</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.disp_edges" title="specless.automaton.pdfa.PDFA.disp_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disp_edges</span></code></a></p></td>
<td><p>Prints each edge in the graph in an edge-list tuple format</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.disp_nodes" title="specless.automaton.pdfa.PDFA.disp_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disp_nodes</span></code></a></p></td>
<td><p>Prints each node's data view</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.draw" title="specless.automaton.pdfa.PDFA.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw</span></code></a></p></td>
<td><p>Draws (can save) the automaton structure in a way compatible with a jupyter / IPython notebook</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edge_subgraph" title="specless.automaton.pdfa.PDFA.edge_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_subgraph</span></code></a></p></td>
<td><p>Returns the subgraph induced by the specified edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.generate_trace" title="specless.automaton.pdfa.PDFA.generate_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_trace</span></code></a></p></td>
<td><p>Generates a trace w/ prob.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.generate_traces" title="specless.automaton.pdfa.PDFA.generate_traces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_traces</span></code></a></p></td>
<td><p>generates num_samples random traces from the automaton</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.get_edge_data" title="specless.automaton.pdfa.PDFA.get_edge_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_data</span></code></a></p></td>
<td><p>Returns the attribute dictionary associated with edge (u, v, key).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_edge" title="specless.automaton.pdfa.PDFA.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge</span></code></a></p></td>
<td><p>Returns True if the graph has an edge between nodes u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_node" title="specless.automaton.pdfa.PDFA.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node</span></code></a></p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_predecessor" title="specless.automaton.pdfa.PDFA.has_predecessor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_predecessor</span></code></a></p></td>
<td><p>Returns True if node u has predecessor v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_successor" title="specless.automaton.pdfa.PDFA.has_successor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_successor</span></code></a></p></td>
<td><p>Returns True if node u has successor v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_directed" title="specless.automaton.pdfa.PDFA.is_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_directed</span></code></a></p></td>
<td><p>Returns True if graph is directed, False otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_multigraph" title="specless.automaton.pdfa.PDFA.is_multigraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multigraph</span></code></a></p></td>
<td><p>Returns True if graph is a multigraph, False otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.kldivergence" title="specless.automaton.pdfa.PDFA.kldivergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kldivergence</span></code></a></p></td>
<td><p>Forward KL Divergence Use ForwardKL on traces generated by this automaton.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.logscore" title="specless.automaton.pdfa.PDFA.logscore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logscore</span></code></a></p></td>
<td><p>Computes the log of the score (sequence probability) of the given trace in the language of the PDFA</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.logscores" title="specless.automaton.pdfa.PDFA.logscores"><code class="xref py py-obj docutils literal notranslate"><span class="pre">logscores</span></code></a></p></td>
<td><p>Computes traces log probabilities</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.mdi_score" title="specless.automaton.pdfa.PDFA.mdi_score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdi_score</span></code></a></p></td>
<td><p>computes the mdi score given a list of traces and the current automata</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.most_probable_string" title="specless.automaton.pdfa.PDFA.most_probable_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">most_probable_string</span></code></a></p></td>
<td><p>Computes the bounded, most probable string in the probabilistic language of the automaton.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.nbunch_iter" title="specless.automaton.pdfa.PDFA.nbunch_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbunch_iter</span></code></a></p></td>
<td><p>Returns an iterator over nodes contained in nbunch that are also in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.neighbors" title="specless.automaton.pdfa.PDFA.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors</span></code></a></p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.new_edge_key" title="specless.automaton.pdfa.PDFA.new_edge_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new_edge_key</span></code></a></p></td>
<td><p>Returns an unused key for edges between nodes <cite>u</cite> and <cite>v</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.norm" title="specless.automaton.pdfa.PDFA.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a></p></td>
<td><p>computes Ln Norm (default n=2)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_edges" title="specless.automaton.pdfa.PDFA.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a></p></td>
<td><p>Returns the number of edges between two nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_nodes" title="specless.automaton.pdfa.PDFA.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a></p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.observe" title="specless.automaton.pdfa.PDFA.observe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">observe</span></code></a></p></td>
<td><p>Returns the given state's observation symbol</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.order" title="specless.automaton.pdfa.PDFA.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.perplexity" title="specless.automaton.pdfa.PDFA.perplexity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perplexity</span></code></a></p></td>
<td><p>computes actual perplexity of the given traces in the language of the PDFA on the given actual trace probabilities</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.perplexity_approx" title="specless.automaton.pdfa.PDFA.perplexity_approx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perplexity_approx</span></code></a></p></td>
<td><p>computes approximate perplexity of the given trace in the language of the PDFA</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.plot_node_trans_dist" title="specless.automaton.pdfa.PDFA.plot_node_trans_dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_node_trans_dist</span></code></a></p></td>
<td><p>Plots the transition pmf at the given curr_state / node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predecessors" title="specless.automaton.pdfa.PDFA.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></p></td>
<td><p>Returns an iterator over predecessor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predict" title="specless.automaton.pdfa.PDFA.predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predict</span></code></a></p></td>
<td><p>predicts the next symbol conditioned on the given previous symbols</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predictive_accuracy" title="specless.automaton.pdfa.PDFA.predictive_accuracy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predictive_accuracy</span></code></a></p></td>
<td><p>compares the model's predictions to the actual values of the next symbol and returns the ratio of correct predictions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">refit_prob_dist</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edge" title="specless.automaton.pdfa.PDFA.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a></p></td>
<td><p>Remove an edge between u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edges_from" title="specless.automaton.pdfa.PDFA.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a></p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_node" title="specless.automaton.pdfa.PDFA.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code></a></p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_nodes_from" title="specless.automaton.pdfa.PDFA.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code></a></p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.reverse" title="specless.automaton.pdfa.PDFA.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a></p></td>
<td><p>Returns the reverse of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.reverse_kldivergence" title="specless.automaton.pdfa.PDFA.reverse_kldivergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse_kldivergence</span></code></a></p></td>
<td><p>Reverse KL Divergence Use ReverseKL on traces generated by other automaton</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.score" title="specless.automaton.pdfa.PDFA.score"><code class="xref py py-obj docutils literal notranslate"><span class="pre">score</span></code></a></p></td>
<td><p>Calculates the given trace's probability in the language of the PDFA.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.scores" title="specless.automaton.pdfa.PDFA.scores"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scores</span></code></a></p></td>
<td><p>Calculates trace probabilities</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.size" title="specless.automaton.pdfa.PDFA.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></p></td>
<td><p>Returns the number of edges or total of all edge weights.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.subgraph" title="specless.automaton.pdfa.PDFA.subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraph</span></code></a></p></td>
<td><p>Returns a SubGraph view of the subgraph induced on <cite>nodes</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.successors" title="specless.automaton.pdfa.PDFA.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code></a></p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_directed" title="specless.automaton.pdfa.PDFA.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a></p></td>
<td><p>Returns a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_directed_class" title="specless.automaton.pdfa.PDFA.to_directed_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed_class</span></code></a></p></td>
<td><p>Returns the class to use for empty directed copies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_undirected" title="specless.automaton.pdfa.PDFA.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code></a></p></td>
<td><p>Returns an undirected representation of the digraph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_undirected_class" title="specless.automaton.pdfa.PDFA.to_undirected_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected_class</span></code></a></p></td>
<td><p>Returns the class to use for empty undirected copies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.update" title="specless.automaton.pdfa.PDFA.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a></p></td>
<td><p>Update the graph using nodes/edges/graphs as input.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.write_traces_to_file" title="specless.automaton.pdfa.PDFA.write_traces_to_file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_traces_to_file</span></code></a></p></td>
<td><p>Writes trace samples to a file in the abbadingo format for use in grammatical inference tools like flexfringe</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adj" title="specless.automaton.pdfa.PDFA.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adj</span></code></a></p></td>
<td><p>Graph adjacency object holding the neighbors of each node.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">automata_data_dir</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">automata_display_data_dir_name</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.degree" title="specless.automaton.pdfa.PDFA.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a></p></td>
<td><p>A DegreeView for the Graph as G.degree or G.degree().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edges" title="specless.automaton.pdfa.PDFA.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></p></td>
<td><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_degree" title="specless.automaton.pdfa.PDFA.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></p></td>
<td><p>A DegreeView for (node, in_degree) or in_degree for single node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_edges" title="specless.automaton.pdfa.PDFA.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a></p></td>
<td><p>A view of the in edges of the graph as G.in_edges or G.in_edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.name" title="specless.automaton.pdfa.PDFA.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></p></td>
<td><p>String identifier of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.nodes" title="specless.automaton.pdfa.PDFA.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a></p></td>
<td><p>A NodeView of the Graph as G.nodes or G.nodes().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_degree" title="specless.automaton.pdfa.PDFA.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a></p></td>
<td><p>Returns an iterator for (node, out-degree) or out-degree for single node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_edges" title="specless.automaton.pdfa.PDFA.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></p></td>
<td><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.pred" title="specless.automaton.pdfa.PDFA.pred"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pred</span></code></a></p></td>
<td><p>Graph adjacency object holding the predecessors of each node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.succ" title="specless.automaton.pdfa.PDFA.succ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">succ</span></code></a></p></td>
<td><p>Graph adjacency object holding the successors of each node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.alphabet_size" title="specless.automaton.pdfa.PDFA.alphabet_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alphabet_size</span></code></a></p></td>
<td><p>number of symbols in automaton alphabet</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.num_states" title="specless.automaton.pdfa.PDFA.num_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_states</span></code></a></p></td>
<td><p>number of states in automaton state space</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.num_obs" title="specless.automaton.pdfa.PDFA.num_obs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_obs</span></code></a></p></td>
<td><p>number of state observations in TS obs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.final_transition_sym" title="specless.automaton.pdfa.PDFA.final_transition_sym"><code class="xref py py-obj docutils literal notranslate"><span class="pre">final_transition_sym</span></code></a></p></td>
<td><p>representation of the termination symbol</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.empty_transition_sym" title="specless.automaton.pdfa.PDFA.empty_transition_sym"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty_transition_sym</span></code></a></p></td>
<td><p>symbol to use as the empty (a.k.a.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.start_state" title="specless.automaton.pdfa.PDFA.start_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_state</span></code></a></p></td>
<td><p>unique start state string label of automaton</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_stochastic" title="specless.automaton.pdfa.PDFA.is_stochastic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_stochastic</span></code></a></p></td>
<td><p>whether symbol probabilities are given for string generation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_sampleable" title="specless.automaton.pdfa.PDFA.is_sampleable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_sampleable</span></code></a></p></td>
<td><p>transitions will have pre-computed, well-formed distributions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_normalized" title="specless.automaton.pdfa.PDFA.is_normalized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_normalized</span></code></a></p></td>
<td><p>ill-defined transition distributions are normalized to be proper probability distributions over outgoing transitions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.symbols" title="specless.automaton.pdfa.PDFA.symbols"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symbols</span></code></a></p></td>
<td><p>set of all symbols used by the automaton</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.state_labels" title="specless.automaton.pdfa.PDFA.state_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_labels</span></code></a></p></td>
<td><p>set of all states in the automaton</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.observations" title="specless.automaton.pdfa.PDFA.observations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">observations</span></code></a></p></td>
<td><p>the set of all possible state output symbols (observations)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_deterministic" title="specless.automaton.pdfa.PDFA.is_deterministic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_deterministic</span></code></a></p></td>
<td><p>whether or not there is a unique state dest.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_for_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_for_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.add_edge" title="Link to this definition">¶</a></dt>
<dd><p>Add an edge between u and v.</p>
<p>The nodes u and v will be automatically added if they are
not already in the graph.</p>
<p>Edge attributes can be specified with keywords or by directly
accessing the edge’s attribute dictionary. See examples below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u_for_edge</strong> (<em>nodes</em>) – Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</p></li>
<li><p><strong>v_for_edge</strong> (<em>nodes</em>) – Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</p></li>
<li><p><strong>key</strong> (<em>hashable identifier</em><em>, </em><em>optional</em><em> (</em><em>default=lowest unused integer</em><em>)</em>) – Used to distinguish multiedges between a pair of nodes.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em>) – Edge data (or labels or objects) can be assigned using
keyword arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The edge key assigned to the edge.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="specless.automaton.pdfa.PDFA.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add a collection of edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>To replace/update edge data, use the optional key argument
to identify a unique edge.  Otherwise a new edge will be created.</p>
<p>NetworkX algorithms designed for weighted graphs cannot use
multigraphs directly because it is not clear how to handle
multiedge weights.  Convert to Graph using edge attribute
‘weight’ to enable weighted graph algorithms.</p>
<p>Default keys are generated using the method <cite>new_edge_key()</cite>.
This method can be overridden by subclassing the base class and
providing a custom <cite>new_edge_key()</cite> method.</p>
<p class="rubric">Examples</p>
<p>The following all add the edge e=(1, 2) to graph G:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># explicit two-node form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># single edge as tuple of two nodes</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># add edges from iterable container</span>
<span class="go">[2]</span>
</pre></div>
</div>
<p>Associate data to edges using keywords:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># update data for key=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">342.7</span><span class="p">)</span>
</pre></div>
</div>
<p>For non-string attribute keys, use subscript notation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ekey</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch_to_add</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="Link to this definition">¶</a></dt>
<dd><p>Add all the edges in ebunch_to_add.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ebunch_to_add</strong> (<em>container</em><em> of </em><em>edges</em>) – <p>Each edge given in the container will be added to the
graph. The edges can be:</p>
<blockquote>
<div><ul>
<li><p>2-tuples (u, v) or</p></li>
<li><p>3-tuples (u, v, d) for an edge data dict d, or</p></li>
<li><p>3-tuples (u, v, k) for not iterable key k, or</p></li>
<li><p>4-tuples (u, v, k, d) for an edge with data and key k</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em>) – Edge data (or labels or objects) can be assigned using
keyword arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of edge keys assigned to the edges in <cite>ebunch</cite>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edge" title="specless.automaton.pdfa.PDFA.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></dt><dd><p>add a single edge</p>
</dd>
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_weighted_edges_from" title="specless.automaton.pdfa.PDFA.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></a></dt><dd><p>convenient way to add weighted edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding the same edge twice has no effect but any edge data
will be updated when each duplicate edge is added.</p>
<p>Edge attributes specified in an ebunch take precedence over
attributes specified via keyword arguments.</p>
<p>Default keys are generated using the method <code class="docutils literal notranslate"><span class="pre">new_edge_key()</span></code>.
This method can be overridden by subclassing the base class and
providing a custom <code class="docutils literal notranslate"><span class="pre">new_edge_key()</span></code> method.</p>
<p>When adding edges from an iterator over the graph you are changing,
a <cite>RuntimeError</cite> can be raised with message:
<cite>RuntimeError: dictionary changed size during iteration</cite>. This
happens when the graph’s underlying dictionary is modified during
iteration. To avoid this error, evaluate the iterator into a separate
object, e.g. by using <cite>list(iterator_of_edges)</cite>, and pass this
object to <cite>G.add_edges_from</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># using a list of edge tuples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># Add the path graph 0-1-2-3</span>
</pre></div>
</div>
<p>Associate data to edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;WN2898&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Evaluate an iterator over a graph if using it to modify the same graph</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Grow graph by one new node, adding edges to all existing nodes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># wrong way - will raise RuntimeError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G.add_edges_from(((5, n) for n in G.nodes))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># right way - note that there will be no self-edge for node 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">assigned_keys</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_for_adding</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.add_node" title="Link to this definition">¶</a></dt>
<dd><p>Add a single node <cite>node_for_adding</cite> and update node attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_for_adding</strong> (<em>node</em>) – A node can be any hashable Python object except None.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em>) – Set or change node attributes using key=value.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_nodes_from" title="specless.automaton.pdfa.PDFA.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Use keywords set/change node attributes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">UTM</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;13S&#39;</span><span class="p">,</span> <span class="mi">382871</span><span class="p">,</span> <span class="mi">3972649</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>A hashable object is one that can be used as a key in a Python
dictionary. This includes strings, numbers, tuples of strings
and numbers, etc.</p>
<p>On many platforms hashable items also include mutables such as
NetworkX Graphs, though one should be careful that the hash
doesn’t change on mutables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_for_adding</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.add_nodes_from" title="Link to this definition">¶</a></dt>
<dd><p>Add multiple nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes_for_adding</strong> (<em>iterable container</em>) – A container of nodes (list, dict, set, etc.).
OR
A container of (node, attribute dict) tuples.
Node attributes are updated using the attribute dict.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em><em> (</em><em>default= no attributes</em><em>)</em>) – Update attributes for all nodes in nodes.
Node attributes specified in nodes as a tuple take
precedence over attributes specified via keyword arguments.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_node" title="specless.automaton.pdfa.PDFA.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>When adding nodes from an iterator over the graph you are changing,
a <cite>RuntimeError</cite> can be raised with message:
<cite>RuntimeError: dictionary changed size during iteration</cite>. This
happens when the graph’s underlying dictionary is modified during
iteration. To avoid this error, evaluate the iterator into a separate
object, e.g. by using <cite>list(iterator_of_nodes)</cite>, and pass this
object to <cite>G.add_nodes_from</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[0, 1, 2, &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;o&#39;]</span>
</pre></div>
</div>
<p>Use keywords to update specific node attributes for every node.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
</pre></div>
</div>
<p>Use (node, attrdict) tuples to update attributes for specific nodes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">)),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">})])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span>
<span class="go">11</span>
</pre></div>
</div>
<p>Evaluate an iterator over a graph if using it to modify the same graph</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># wrong way - will raise RuntimeError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G.add_nodes_from(n + 1 for n in G.nodes)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># correct way</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.add_weighted_edges_from">
<span class="sig-name descname"><span class="pre">add_weighted_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch_to_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.add_weighted_edges_from" title="Link to this definition">¶</a></dt>
<dd><p>Add weighted edges in <cite>ebunch_to_add</cite> with specified weight attr</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ebunch_to_add</strong> (<em>container</em><em> of </em><em>edges</em>) – Each edge given in the list or container will be added
to the graph. The edges must be given as 3-tuples (u, v, w)
where w is a number.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em>, </em><em>optional</em><em> (</em><em>default= 'weight'</em><em>)</em>) – The attribute name for the edge weights to be added.</p></li>
<li><p><strong>attr</strong> (<em>keyword arguments</em><em>, </em><em>optional</em><em> (</em><em>default= no attributes</em><em>)</em>) – Edge attributes to add/update for all edges.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edge" title="specless.automaton.pdfa.PDFA.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></dt><dd><p>add a single edge</p>
</dd>
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="specless.automaton.pdfa.PDFA.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add multiple edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding the same edge twice for Graph/DiGraph simply updates
the edge data. For MultiGraph/MultiDiGraph, duplicate edges
are stored.</p>
<p>When adding edges from an iterator over the graph you are changing,
a <cite>RuntimeError</cite> can be raised with message:
<cite>RuntimeError: dictionary changed size during iteration</cite>. This
happens when the graph’s underlying dictionary is modified during
iteration. To avoid this error, evaluate the iterator into a separate
object, e.g. by using <cite>list(iterator_of_edges)</cite>, and pass this
object to <cite>G.add_weighted_edges_from</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">)])</span>
</pre></div>
</div>
<p>Evaluate an iterator over edges before passing it</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Grow graph by one new node, adding edges to all existing nodes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># wrong way - will raise RuntimeError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># correct way - note that there will be no self-edge for node 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.adj">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adj</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.adj" title="Link to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the neighbors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <cite>G.adj[3][2][0][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2, 0)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <cite>for nbr, foovalue in G[node].data(‘foo’, default=1):</cite> works.</p>
<p>For directed graphs, <cite>G.adj</cite> holds outgoing (successor) info.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.adjacency">
<span class="sig-name descname"><span class="pre">adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.adjacency" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p>
<p>For directed graphs, only outgoing neighbors/adjacencies are included.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>adj_iter</strong> – An iterator over (node, adjacency dictionary) for all nodes in
the graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>iterator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">nbrdict</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrdict</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency</span><span class="p">()]</span>
<span class="go">[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.adjlist_inner_dict_factory">
<span class="sig-name descname"><span class="pre">adjlist_inner_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.adjlist_inner_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.adjlist_outer_dict_factory">
<span class="sig-name descname"><span class="pre">adjlist_outer_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.adjlist_outer_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.alphabet_size">
<span class="sig-name descname"><span class="pre">alphabet_size</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.alphabet_size" title="Link to this definition">¶</a></dt>
<dd><p>number of symbols in automaton alphabet</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.average_norm">
<span class="sig-name descname"><span class="pre">average_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.average_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.average_norm" title="Link to this definition">¶</a></dt>
<dd><p>computes Ln Norm (default n=2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – The list of sequences of symbols to
evaluate the model’s actual cross
entropy on.</p></li>
<li><p><strong>actual_trace_probs</strong> – The actual probability of each trace
in the target language distribution</p></li>
<li><p><strong>n</strong> – n norm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the average ln norm between true and estimated distributions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.clear" title="Link to this definition">¶</a></dt>
<dd><p>Remove all nodes and edges from the graph.</p>
<p>This also removes the name, and all graph, node, and edge attributes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.clear_edges">
<span class="sig-name descname"><span class="pre">clear_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.clear_edges" title="Link to this definition">¶</a></dt>
<dd><p>Remove all edges from the graph without altering nodes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.copy" title="Link to this definition">¶</a></dt>
<dd><p>Returns a copy of the graph.</p>
<p>The copy method by default returns an independent shallow copy
of the graph and attributes. That is, if an attribute is a
container, that container is shared by the original an the copy.
Use Python’s <cite>copy.deepcopy</cite> for new containers.</p>
<p>If <cite>as_view</cite> is True then a view is returned instead of a copy.</p>
<p class="rubric">Notes</p>
<p>All copies reproduce the graph structure, but data attributes
may be handled in different ways. There are four types of copies
of a graph that people might want.</p>
<p>Deepcopy – A “deepcopy” copies the graph structure as well as
all data attributes and any objects they might contain.
The entire graph object is new so that changes in the copy
do not affect the original object. (see Python’s copy.deepcopy)</p>
<p>Data Reference (Shallow) – For a shallow copy the graph structure
is copied but the edge, node and graph attribute dicts are
references to those in the original graph. This saves
time and memory but could cause confusion if you change an attribute
in one graph and it changes the attribute in the other.
NetworkX does not provide this level of shallow copy.</p>
<p>Independent Shallow – This copy creates new independent attribute
dicts and then does a shallow copy of the attributes. That is, any
attributes that are containers are shared between the new graph
and the original. This is exactly what <cite>dict.copy()</cite> provides.
You can obtain this style copy using:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">as_view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Fresh Data – For fresh data, the graph structure is copied while
new empty data attribute dicts are created. The resulting graph
is independent of the original and it has no edge, node or graph
attributes. Fresh copies are not enabled. Instead use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
<p>View – Inspired by dict-views, graph-views act like read-only
versions of the original graph, providing a copy of the original
structure without requiring any memory for copying the information.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>as_view</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, the returned graph-view provides a read-only view
of the original graph without actually copying any data.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – A copy of the graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Graph</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_directed" title="specless.automaton.pdfa.PDFA.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a></dt><dd><p>return a directed copy of the graph.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.cross_entropy">
<span class="sig-name descname"><span class="pre">cross_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.cross_entropy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.cross_entropy" title="Link to this definition">¶</a></dt>
<dd><p>computes actual cross-entropy of the given traces in the language of
the PDFA on the given actual trace probabilities</p>
<p>References:
Speech and Language Processing (SLP), 3 ed., Ch3
(<a class="reference external" href="https://web.stanford.edu/~jurafsky/slp3/3.pdf">https://web.stanford.edu/~jurafsky/slp3/3.pdf</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – The list of sequences of symbols to
evaluate the model’s actual cross
entropy on.</p></li>
<li><p><strong>actual_trace_probs</strong> – The actual probability of each trace
in the target language distribution</p></li>
<li><p><strong>base</strong> – The log base. Commonly set to 2 in
classic information theory literature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the actual cross-entropy of the given trace</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.cross_entropy_approx">
<span class="sig-name descname"><span class="pre">cross_entropy_approx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.cross_entropy_approx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.cross_entropy_approx" title="Link to this definition">¶</a></dt>
<dd><p>computes approximate cross-entropy of the given trace in the language
of the PDFA</p>
<p>Here, we are using the Shannon-McMillian-Breiman theorem to define
the cross-entropy of the trace, given that we sampled the trace from
the actual target distribution and we are evaluating it in the PDFA LM.
Then, as a PDFA is a stationary ergodic stochastic process model, we
can calculate the cross-entropy as (eq. 3.49 from SLP ch3):</p>
<blockquote>
<div><p>trace ~ target
H(target, model) = lim {(- 1 / n) * log(P_{model}(trace))}</p>
<blockquote>
<div><p>n -&gt; inf</p>
</div></blockquote>
</div></blockquote>
<p>where:</p>
<blockquote>
<div><p>H(target) &lt;= H(target, model)</p>
</div></blockquote>
<p>The finite-length approximation to the cross-entropy is then given by
(eq. 3.51 from SLP ch3):</p>
<blockquote>
<div><p>H(trace) = (- 1 / N) log(P_{model}(trace))</p>
</div></blockquote>
<p>References:
NLTK.lm.api
Speech and Language Processing (SLP), 3 ed., Ch3
(<a class="reference external" href="https://web.stanford.edu/~jurafsky/slp3/3.pdf">https://web.stanford.edu/~jurafsky/slp3/3.pdf</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trace</strong> – The sequence of symbols to evaluate</p></li>
<li><p><strong>base</strong> – The log base. Commonly set to 2 in classic
information theory literature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the approximate cross-entropy of the given trace</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">degree</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.degree" title="Link to this definition">¶</a></dt>
<dd><p>A DegreeView for the Graph as G.degree or G.degree().</p>
<p>The node degree is the number of edges adjacent to the node.
The weighted node degree is the sum of the edge weights for
edges incident to that node.</p>
<p>This object provides an iterator for (node, degree) as well as
lookup for the degree for a single node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges incident to these nodes.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The name of an edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights adjacent to the node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If multiple nodes are requested (the default), returns a <cite>DiMultiDegreeView</cite>
mapping nodes to their degree.
If a single node is requested, returns the degree of the node as an integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DiMultiDegreeView or int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_degree" title="specless.automaton.pdfa.PDFA.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_degree" title="specless.automaton.pdfa.PDFA.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (1, 2), (2, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># parallel edge</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="c1"># parallel edges are counted</span>
<span class="go">[(0, 2), (1, 3), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.disp_edges">
<span class="sig-name descname"><span class="pre">disp_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph:</span> <span class="pre">{None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'networkx.classes.multidigraph.MultiDiGraph'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.disp_edges" title="Link to this definition">¶</a></dt>
<dd><p>Prints each edge in the graph in an edge-list tuple format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>graph</strong> (<em>{None</em><em>, </em><em>nx.MultiDiGraph}</em>) – The graph to access. Default = None =&gt; use instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.disp_nodes">
<span class="sig-name descname"><span class="pre">disp_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph:</span> <span class="pre">{None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'networkx.classes.multidigraph.MultiDiGraph'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.disp_nodes" title="Link to this definition">¶</a></dt>
<dd><p>Prints each node’s data view</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>graph</strong> (<em>{None</em><em>, </em><em>nx.MultiDiGraph}</em>) – The graph to access. Default = None =&gt; use instance</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename:</span> <span class="pre">{None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'str'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">should_display:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img_format='png'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.draw" title="Link to this definition">¶</a></dt>
<dd><p>Draws (can save) the automaton structure in a way compatible with a
jupyter / IPython notebook</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> – The filename to save the automaton image</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.edge_attr_dict_factory">
<span class="sig-name descname"><span class="pre">edge_attr_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.edge_attr_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.edge_key_dict_factory">
<span class="sig-name descname"><span class="pre">edge_key_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.edge_key_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.edge_subgraph">
<span class="sig-name descname"><span class="pre">edge_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.edge_subgraph" title="Link to this definition">¶</a></dt>
<dd><p>Returns the subgraph induced by the specified edges.</p>
<p>The induced subgraph contains each edge in <cite>edges</cite> and each
node incident to any one of those edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>edges</strong> (<em>iterable</em>) – An iterable of edges in this graph.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – An edge-induced subgraph of this graph with the same edge
attributes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Graph</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The graph, edge, and node attributes in the returned subgraph
view are references to the corresponding attributes in the original
graph. The view is read-only.</p>
<p>To create a full graph version of the subgraph with its own copy
of the edge or node attributes, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (3, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.edges">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edges</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.edges" title="Link to this definition">¶</a></dt>
<dd><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p>
<p>edges(self, nbunch=None, data=False, keys=False, default=None)</p>
<p>The OutMultiEdgeView provides set-like operations on the edge-tuples
as well as edge attribute lookup. When called, it also provides
an EdgeDataView object which allows control of access to edge
attributes (but does not provide set-like operations).
Hence, <code class="docutils literal notranslate"><span class="pre">G.edges[u,</span> <span class="pre">v,</span> <span class="pre">k]['color']</span></code> provides the value of the color
attribute for the edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code> with key <code class="docutils literal notranslate"><span class="pre">k</span></code> while
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">k,</span> <span class="pre">c)</span> <span class="pre">in</span> <span class="pre">G.edges(data='color',</span> <span class="pre">default='red',</span> <span class="pre">keys=True):</span></code>
iterates through all the edges yielding the color attribute with
default <cite>‘red’</cite> if no color attribute exists.</p>
<p>Edges are returned as tuples with optional data and keys
in the order (node, neighbor, key, data). If <code class="docutils literal notranslate"><span class="pre">keys=True</span></code> is not
provided, the tuples will just be (node, neighbor, data), but
multiple tuples with the same node and neighbor will be
generated when multiple edges between two nodes exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges from these nodes.</p></li>
<li><p><strong>data</strong> (<em>string</em><em> or </em><em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – The edge attribute returned in 3-tuple (u, v, ddict[data]).
If True, return edge attribute dict in 3-tuple (u, v, ddict).
If False, return 2-tuple (u, v).</p></li>
<li><p><strong>keys</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, return edge keys with each edge, creating (u, v, k,
d) tuples when data is also requested (the default) and (u,
v, k) tuples when data is not requested.</p></li>
<li><p><strong>default</strong> (<em>value</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Value used for edges that don’t have the requested attribute.
Only relevant if data is not True or False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>edges</strong> – A view of edge attributes, usually it iterates over (u, v)
(u, v, k) or (u, v, k, d) tuples of edges, but can also be
used for attribute lookup as <code class="docutils literal notranslate"><span class="pre">edges[u,</span> <span class="pre">v,</span> <span class="pre">k]['foo']</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OutMultiEdgeView</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Nodes in nbunch that are not in the graph will be (quietly) ignored.
For directed graphs this returns the out-edges.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># second edge between these nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="go">[(0, 1), (1, 2), (1, 2), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default data is {} (empty dict)</span>
<span class="go">[(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default keys are integers</span>
<span class="go">[(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_edges" title="specless.automaton.pdfa.PDFA.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_edges" title="specless.automaton.pdfa.PDFA.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.empty_transition_sym">
<span class="sig-name descname"><span class="pre">empty_transition_sym</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.empty_transition_sym" title="Link to this definition">¶</a></dt>
<dd><p>symbol to use as the empty (a.k.a. lambda) symbol</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.final_transition_sym">
<span class="sig-name descname"><span class="pre">final_transition_sym</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.final_transition_sym" title="Link to this definition">¶</a></dt>
<dd><p>representation of the termination symbol</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.generate_trace">
<span class="sig-name descname"><span class="pre">generate_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">start_state:</span> <span class="pre">~typing.Hashable,</span> <span class="pre">N:</span> <span class="pre">int,</span> <span class="pre">max_resamples:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10,</span> <span class="pre">return_whatever_you_got:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">random_state:</span> <span class="pre">{None,</span> <span class="pre">&lt;class</span> <span class="pre">'int'&gt;,</span> <span class="pre">typing.Iterable}</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">(typing.Iterable[typing.Hashable],</span> <span class="pre">&lt;class</span> <span class="pre">'int'&gt;,</span> <span class="pre">&lt;class</span> <span class="pre">'float'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.generate_trace" title="Link to this definition">¶</a></dt>
<dd><p>Generates a trace w/ prob. &gt; 0 from the automaton from its start_state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_state</strong> – the state label to start sampling
traces from</p></li>
<li><p><strong>N</strong> – maximum length of trace</p></li>
<li><p><strong>max_resamples</strong> – The maximum number of times to
resample if if we create a trace
of length N that still doesn’t
have a probability &gt; 0 in the
language</p></li>
<li><p><strong>return_whatever_you_got</strong> – Whether to return a string with a
zero probability after all
resampling attempts are
exhausted.</p></li>
<li><p><strong>random_state</strong> – The np.random.RandomState() seed
parameter for sampling from the
state transition distribution.
Defaulting to None causes the
seed to reset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the sequence of symbols emitted, the length of the trace,
the probability of the trace in the language of the
automaton</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if you try to generate a trace
from a non-sampleable automaton</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.generate_traces">
<span class="sig-name descname"><span class="pre">generate_traces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_resamples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_whatever_you_got</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_multicore</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.generate_traces" title="Link to this definition">¶</a></dt>
<dd><p>generates num_samples random traces from the automaton</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_samples</strong> – The number of trace samples to
generate</p></li>
<li><p><strong>N</strong> – maximum length of trace</p></li>
<li><p><strong>max_resamples</strong> – The maximum number of times to
resample if if we create a trace
of length N that still doesn’t
have a probability &gt; 0 in the
language</p></li>
<li><p><strong>return_whatever_you_got</strong> – Whether to return a string with a
zero probability after all
resampling attempts are
exhausted.</p></li>
<li><p><strong>force_multicore</strong> – whether to force use the threaded
sampler this is set by default to
optimize speed, as the threaded
sampler is slower for smaller
num_samples. Force this to be
true if the automaton is slow to
sample.</p></li>
<li><p><strong>verbose</strong> – verbose for joblib.Parallel</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of sampled traces, list of the associated trace
lengths, list of the associated trace probabilities</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple(list(list(int)), list(int), list(float))</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.get_edge_data">
<span class="sig-name descname"><span class="pre">get_edge_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.get_edge_data" title="Link to this definition">¶</a></dt>
<dd><p>Returns the attribute dictionary associated with edge (u, v,
key).</p>
<p>If a key is not provided, returns a dictionary mapping edge keys
to attribute dictionaries for each edge between u and v.</p>
<p>This is identical to <cite>G[u][v][key]</cite> except the default is returned
instead of an exception is the edge doesn’t exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>nodes</em>) – </p></li>
<li><p><strong>v</strong> (<em>nodes</em>) – </p></li>
<li><p><strong>default</strong> (<em>any Python object</em><em> (</em><em>default=None</em><em>)</em>) – Value to return if the specific edge (u, v, key) is not
found, OR if there are no edges between u and v and no key
is specified.</p></li>
<li><p><strong>key</strong> (<em>hashable identifier</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Return data only for the edge with specified key, as an
attribute dictionary (rather than a dictionary mapping keys
to attribute dictionaries).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>edge_dict</strong> – The edge attribute dictionary, OR a dictionary mapping edge
keys to attribute dictionaries for each of those edges if no
specific key is provided (even if there’s only one edge
between u and v).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>  <span class="c1"># key=&#39;a&#39;</span>
<span class="go">{&#39;weight&#39;: 7}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">]</span>  <span class="c1"># key=&#39;a&#39;</span>
<span class="go">{&#39;weight&#39;: 7}</span>
</pre></div>
</div>
<p>Warning: we protect the graph data structure by making
<cite>G.edges</cite> and <cite>G[1][2]</cite> read-only dict-like structures.
However, you can assign values to attributes in e.g.
<cite>G.edges[1, 2, ‘a’]</cite> or <cite>G[1][2][‘a’]</cite> using an additional
bracket as shown next. You need to specify all edge info
to assign to the edge data associated with an edge.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
<span class="go">10</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">{0: {&#39;weight&#39;: 5}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># tuple form</span>
<span class="go">{0: {&#39;weight&#39;: 5}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># edge not in graph, returns None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># edge not in graph, return default</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># specific key gives back</span>
<span class="go">{&#39;weight&#39;: 5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.graph_attr_dict_factory">
<span class="sig-name descname"><span class="pre">graph_attr_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.graph_attr_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.has_edge">
<span class="sig-name descname"><span class="pre">has_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.has_edge" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if the graph has an edge between nodes u and v.</p>
<p>This is the same as <cite>v in G[u] or key in G[u][v]</cite>
without KeyError exceptions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>nodes</em>) – Nodes can be, for example, strings or numbers.</p></li>
<li><p><strong>v</strong> (<em>nodes</em>) – Nodes can be, for example, strings or numbers.</p></li>
<li><p><strong>key</strong> (<em>hashable identifier</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – If specified return True only if the edge with
key is found.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>edge_ind</strong> – True if edge is in the graph, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Can be called either using two nodes u, v, an edge tuple (u, v),
or an edge tuple (u, v, key).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># using two nodes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1">#  e is a 2-tuple (u, v)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>  <span class="c1"># specify key</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>  <span class="c1"># edges aren&#39;t directed</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># e is a 3-tuple (u, v, &#39;a&#39;)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following syntax are equivalent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># though this gives :exc:`KeyError` if 0 not in G</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># other order; also gives :exc:`KeyError` if 0 not in G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.has_node">
<span class="sig-name descname"><span class="pre">has_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.has_node" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if the graph contains the node n.</p>
<p>Identical to <cite>n in G</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>node</em>) – </p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is more readable and simpler to use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.has_predecessor">
<span class="sig-name descname"><span class="pre">has_predecessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.has_predecessor" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if node u has predecessor v.</p>
<p>This is true if graph has the edge u&lt;-v.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.has_successor">
<span class="sig-name descname"><span class="pre">has_successor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.has_successor" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if node u has successor v.</p>
<p>This is true if graph has the edge u-&gt;v.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.in_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_degree</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.in_degree" title="Link to this definition">¶</a></dt>
<dd><p>A DegreeView for (node, in_degree) or in_degree for single node.</p>
<p>The node in-degree is the number of edges pointing into the node.
The weighted node degree is the sum of the edge weights for
edges incident to that node.</p>
<p>This object provides an iterator for (node, degree) as well as
lookup for the degree for a single node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges incident to these nodes.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights adjacent to the node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>If a single node is requested</em></p></li>
<li><p><strong>deg</strong> (<em>int</em>) – Degree of the node</p></li>
<li><p><em>OR if multiple nodes are requested</em></p></li>
<li><p><strong>nd_iter</strong> (<em>iterator</em>) – The iterator returns two-tuples of (node, in-degree).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.degree" title="specless.automaton.pdfa.PDFA.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_degree" title="specless.automaton.pdfa.PDFA.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 0</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 0), (1, 1), (2, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># parallel edge</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="c1"># parallel edges counted</span>
<span class="go">[(0, 0), (1, 2), (2, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.in_edges">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_edges</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.in_edges" title="Link to this definition">¶</a></dt>
<dd><p>A view of the in edges of the graph as G.in_edges or G.in_edges().</p>
<p>in_edges(self, nbunch=None, data=False, keys=False, default=None)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges incident to these nodes.</p></li>
<li><p><strong>data</strong> (<em>string</em><em> or </em><em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – The edge attribute returned in 3-tuple (u, v, ddict[data]).
If True, return edge attribute dict in 3-tuple (u, v, ddict).
If False, return 2-tuple (u, v).</p></li>
<li><p><strong>keys</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, return edge keys with each edge, creating 3-tuples
(u, v, k) or with data, 4-tuples (u, v, k, d).</p></li>
<li><p><strong>default</strong> (<em>value</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Value used for edges that don’t have the requested attribute.
Only relevant if data is not True or False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>in_edges</strong> – A view of edge attributes, usually it iterates over (u, v)
or (u, v, k) or (u, v, k, d) tuples of edges, but can also be
used for attribute lookup as <cite>edges[u, v, k][‘foo’]</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>InMultiEdgeView or InMultiEdgeDataView</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edges" title="specless.automaton.pdfa.PDFA.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_deterministic">
<span class="sig-name descname"><span class="pre">is_deterministic</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_deterministic" title="Link to this definition">¶</a></dt>
<dd><p>whether or not there is a unique state dest. under each symbol.
Defaults to true and is falsified later during initialization.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_directed">
<span class="sig-name descname"><span class="pre">is_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_directed" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if graph is directed, False otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_multigraph">
<span class="sig-name descname"><span class="pre">is_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_multigraph" title="Link to this definition">¶</a></dt>
<dd><p>Returns True if graph is a multigraph, False otherwise.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_normalized">
<span class="sig-name descname"><span class="pre">is_normalized</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_normalized" title="Link to this definition">¶</a></dt>
<dd><p>ill-defined transition distributions are normalized to be proper
probability distributions over outgoing transitions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_sampleable">
<span class="sig-name descname"><span class="pre">is_sampleable</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_sampleable" title="Link to this definition">¶</a></dt>
<dd><p>transitions will have pre-computed, well-formed distributions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.is_stochastic">
<span class="sig-name descname"><span class="pre">is_stochastic</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.is_stochastic" title="Link to this definition">¶</a></dt>
<dd><p>whether symbol probabilities are given for string generation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.kldivergence">
<span class="sig-name descname"><span class="pre">kldivergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.kldivergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.kldivergence" title="Link to this definition">¶</a></dt>
<dd><p>Forward KL Divergence
Use ForwardKL on traces generated by this automaton.</p>
<p>KL(p||q) =  p log(p) - p log(q)</p>
<p>where p is the true probability and q is the estimated probability
q must not be 0 otherwise the KL divergence goes to infinity.
Therefore, we must be certain that the traces were generated by
this automaton, so that q is always positive q&gt;0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.logscore">
<span class="sig-name descname"><span class="pre">logscore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.logscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.logscore" title="Link to this definition">¶</a></dt>
<dd><p>Computes the log of the score (sequence probability) of the given trace
in the language of the PDFA</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trace</strong> – The sequence of symbols to compute the log score of</p></li>
<li><p><strong>base</strong> – The log base. Commonly set to 2 in classic
information theory literature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>log of the probability - NOT log odds</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.logscores">
<span class="sig-name descname"><span class="pre">logscores</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.logscores"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.logscores" title="Link to this definition">¶</a></dt>
<dd><p>Computes traces log probabilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – A list of traces</p></li>
<li><p><strong>base</strong> – The log base.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>log of the probability</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.mdi_score">
<span class="sig-name descname"><span class="pre">mdi_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.mdi_score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.mdi_score" title="Link to this definition">¶</a></dt>
<dd><p>computes the mdi score given a list of traces and the current
automata</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>traces</strong> – The list of sequences of symbols to
evaluate the model’s MDI score.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the MDI score</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.most_probable_string">
<span class="sig-name descname"><span class="pre">most_probable_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_string_probability:</span> <span class="pre">{None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'float'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_string_length:</span> <span class="pre">{None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_empty_symbol:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">try_to_use_greedy:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backwards_search:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_strings_to_find:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth_first:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_entropy:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_pbar:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.most_probable_string" title="Link to this definition">¶</a></dt>
<dd><p>Computes the bounded, most probable string in the probabilistic
language of the automaton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_string_probability</strong> – The minimum string probability.
This setting does nothing if
is_deterministic, as the
deterministic algorithm is exact.
(default 0.0)</p></li>
<li><p><strong>max_string_length</strong> – The maximum string length. This
setting does nothing if
is_deterministic, as the
deterministic algorithm is exact.
(default 100)</p></li>
<li><p><strong>allow_empty_symbol</strong> – Indicates if the empty symbol is
allowed</p></li>
<li><p><strong>try_to_use_greedy</strong> – whether to try using the MUCH
faster greedy search algorithm.
only possible if the automaton has
deterministic transitions. Only
set this to False if the automaton
actually is non-deterministic, as
the non-deterministic solver is an
approximation and MUCH slower.</p></li>
<li><p><strong>backwards_search</strong> – Whether to search from the with
final probability back to the
start state. Often will improve
performance.</p></li>
<li><p><strong>num_strings_to_find</strong> – The number of viable strings to
return. Defaults to only return
the ONE, highest probability
string encountered thus far in the
search, which means the algorithm
is the original BMPS_exact. If &gt;1,
then the algorithm returns the
num_strings_to_find most probable,
viable strings from the search
heap.</p></li>
<li><p><strong>depth_first</strong> – Whether to explore the automaton
using a depth-first search
pattern. Using a depth-first
search pattern will be faster for
very deep, tree-shaped automaton,
but will not return the absolute
best symbol sequence for the given
min_string_prob and
max_string_length. Only turn on if
you have a terminal states deep in
the automaton and you need the
search to be faster.</p></li>
<li><p><strong>add_entropy</strong> – Only keeps a new viable string if
it has a previously unseen
probability of being generated</p></li>
<li><p><strong>disable_pbar</strong> – Disable pbar for speeding up the
computation speed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>most probable string, probability of producing the most
probable string, num_strings_to_find (their probs., viable
strings) ranked by each string’s probability.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – Cannot be computed for
non-stochastic automaton</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.name" title="Link to this definition">¶</a></dt>
<dd><p>String identifier of the graph.</p>
<p>This graph attribute appears in the attribute dict G.graph
keyed by the string <cite>“name”</cite>. as well as an attribute (technically
a property) <cite>G.name</cite>. This is entirely user controlled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.nbunch_iter">
<span class="sig-name descname"><span class="pre">nbunch_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.nbunch_iter" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator over nodes contained in nbunch that are
also in the graph.</p>
<p>The nodes in nbunch are checked for membership in the graph
and if not are silently ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges incident to these nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>niter</strong> – An iterator over nodes in nbunch that are also in the graph.
If nbunch is None, iterate over all nodes in the graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>iterator</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If nbunch is not a node or sequence of nodes.
    If a node in nbunch is not hashable.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__iter__</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>When nbunch is an iterator, the returned iterator yields values
directly from nbunch, becoming exhausted when nbunch is exhausted.</p>
<p>To test whether nbunch is a single node, one can use
“if nbunch in self:”, even after processing with this routine.</p>
<p>If nbunch is not a node or a (possibly empty) sequence/iterator
or None, a <code class="xref py py-exc docutils literal notranslate"><span class="pre">NetworkXError</span></code> is raised.  Also, if any object in
nbunch is not hashable, a <code class="xref py py-exc docutils literal notranslate"><span class="pre">NetworkXError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.neighbors">
<span class="sig-name descname"><span class="pre">neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.neighbors" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator over successor nodes of n.</p>
<p>A successor of n is a node m such that there exists a directed
edge from n to m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>node</em>) – A node in the graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If n is not in the graph.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predecessors" title="specless.automaton.pdfa.PDFA.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>neighbors() and successors() are the same.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.new_edge_key">
<span class="sig-name descname"><span class="pre">new_edge_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.new_edge_key" title="Link to this definition">¶</a></dt>
<dd><p>Returns an unused key for edges between nodes <cite>u</cite> and <cite>v</cite>.</p>
<p>The nodes <cite>u</cite> and <cite>v</cite> do not need to be already in the graph.</p>
<p class="rubric">Notes</p>
<p>In the standard MultiGraph class the new key is the number of existing
edges between <cite>u</cite> and <cite>v</cite> (increased if necessary to ensure unused).
The first edge will have key 0, then 1, etc. If an edge is removed
further new_edge_keys may not be in this order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>nodes</em>) – </p></li>
<li><p><strong>v</strong> (<em>nodes</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>key</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.node_attr_dict_factory">
<span class="sig-name descname"><span class="pre">node_attr_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.node_attr_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.node_dict_factory">
<span class="sig-name descname"><span class="pre">node_dict_factory</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.node_dict_factory" title="Link to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.nodes" title="Link to this definition">¶</a></dt>
<dd><p>A NodeView of the Graph as G.nodes or G.nodes().</p>
<p>Can be used as <cite>G.nodes</cite> for data lookup and for set-like operations.
Can also be used as <cite>G.nodes(data=’color’, default=None)</cite> to return a
NodeDataView which reports specific node data but no set operations.
It presents a dict-like interface as well with <cite>G.nodes.items()</cite>
iterating over <cite>(node, nodedata)</cite> 2-tuples and <cite>G.nodes[3][‘foo’]</cite>
providing the value of the <cite>foo</cite> attribute for node <cite>3</cite>. In addition,
a view <cite>G.nodes.data(‘foo’)</cite> provides a dict-like interface to the
<cite>foo</cite> attribute of each node. <cite>G.nodes.data(‘foo’, default=1)</cite>
provides a default for nodes that do not have attribute <cite>foo</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>string</em><em> or </em><em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – The node attribute returned in 2-tuple (n, ddict[data]).
If True, return entire node attribute dict as (n, ddict).
If False, return just the nodes n.</p></li>
<li><p><strong>default</strong> (<em>value</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Value used for nodes that don’t have the requested attribute.
Only relevant if data is not True or False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Allows set-like operations over the nodes as well as node
attribute dict lookup and calling to get a NodeDataView.
A NodeDataView iterates over <cite>(n, data)</cite> and has no set operations.
A NodeView iterates over <cite>n</cite> and includes set operations.</p>
<p>When called, if data is False, an iterator over nodes.
Otherwise an iterator of 2-tuples (node, attribute value)
where the attribute is specified in <cite>data</cite>.
If data is True then the attribute becomes the
entire data dictionary.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NodeView</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If your node data is not needed, it is simpler and equivalent
to use the expression <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">G</span></code>, or <code class="docutils literal notranslate"><span class="pre">list(G)</span></code>.</p>
<p class="rubric">Examples</p>
<p>There are two simple ways of getting a list of all nodes in the graph:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>To get the node data along with the nodes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s2">&quot;5pm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, {&#39;foo&#39;: &#39;bar&#39;}), (1, {&#39;time&#39;: &#39;5pm&#39;}), (2, {})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="go">[(0, {&#39;foo&#39;: &#39;bar&#39;}), (1, {&#39;time&#39;: &#39;5pm&#39;}), (2, {})]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;bar&#39;), (1, None), (2, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;bar&#39;), (1, None), (2, None)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">))</span>
<span class="go">[(0, None), (1, &#39;5pm&#39;), (2, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">))</span>
<span class="go">[(0, None), (1, &#39;5pm&#39;), (2, None)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;Not Available&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;Not Available&#39;), (1, &#39;5pm&#39;), (2, &#39;Not Available&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;Not Available&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;Not Available&#39;), (1, &#39;5pm&#39;), (2, &#39;Not Available&#39;)]</span>
</pre></div>
</div>
<p>If some of your nodes have an attribute and the rest are assumed
to have a default attribute value you can create a dictionary
from node/attribute pairs using the <cite>default</cite> keyword argument
to guarantee the value is never None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{0: 1, 1: 2, 2: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.norm" title="Link to this definition">¶</a></dt>
<dd><p>computes Ln Norm (default n=2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – The list of sequences of symbols to
evaluate the model’s actual cross
entropy on.</p></li>
<li><p><strong>actual_trace_probs</strong> – The actual probability of each trace
in the target language distribution</p></li>
<li><p><strong>n</strong> – n norm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the ln norm between true and estimated distributions</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.num_obs">
<span class="sig-name descname"><span class="pre">num_obs</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.num_obs" title="Link to this definition">¶</a></dt>
<dd><p>number of state observations in TS obs. space</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.num_states">
<span class="sig-name descname"><span class="pre">num_states</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.num_states" title="Link to this definition">¶</a></dt>
<dd><p>number of states in automaton state space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.number_of_edges">
<span class="sig-name descname"><span class="pre">number_of_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.number_of_edges" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of edges between two nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>nodes</em><em>, </em><em>optional</em><em> (</em><em>Default=all edges</em><em>)</em>) – If u and v are specified, return the number of edges between
u and v. Otherwise return the total number of all edges.</p></li>
<li><p><strong>v</strong> (<em>nodes</em><em>, </em><em>optional</em><em> (</em><em>Default=all edges</em><em>)</em>) – If u and v are specified, return the number of edges between
u and v. Otherwise return the total number of all edges.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>nedges</strong> – The number of edges in the graph.  If nodes <cite>u</cite> and <cite>v</cite> are
specified return the number of edges between those nodes. If
the graph is directed, this only returns the number of edges
from <cite>u</cite> to <cite>v</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.size" title="specless.automaton.pdfa.PDFA.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>For undirected multigraphs, this method counts the total number
of edges in the graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">[0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>If you specify two nodes, this counts the total number of edges
joining the two nodes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For directed multigraphs, this method can count the total number
of directed edges from <cite>u</cite> to <cite>v</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">[0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.number_of_nodes">
<span class="sig-name descname"><span class="pre">number_of_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.number_of_nodes" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nnodes</strong> – The number of nodes in the graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.order" title="specless.automaton.pdfa.PDFA.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></dt><dd><p>identical method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">__len__</span></code></dt><dd><p>identical method</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.observations">
<span class="sig-name descname"><span class="pre">observations</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.observations" title="Link to this definition">¶</a></dt>
<dd><p>the set of all possible state output symbols (observations)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.observe">
<span class="sig-name descname"><span class="pre">observe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curr_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Hashable</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Hashable</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.observe" title="Link to this definition">¶</a></dt>
<dd><p>Returns the given state’s observation symbol</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>curr_state</strong> – The current TS state</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>observation symbol emitted at curr_state</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.order" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nnodes</strong> – The number of nodes in the graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_nodes" title="specless.automaton.pdfa.PDFA.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a></dt><dd><p>identical method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">__len__</span></code></dt><dd><p>identical method</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.out_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_degree</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.out_degree" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator for (node, out-degree) or out-degree for single node.</p>
<p>out_degree(self, nbunch=None, weight=None)</p>
<p>The node out-degree is the number of edges pointing out of the node.
This function returns the out-degree for a single node or an iterator
for a bunch of nodes or if nothing is passed as argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges incident to these nodes.</p></li>
<li><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>If a single node is requested</em></p></li>
<li><p><strong>deg</strong> (<em>int</em>) – Degree of the node</p></li>
<li><p><em>OR if multiple nodes are requested</em></p></li>
<li><p><strong>nd_iter</strong> (<em>iterator</em>) – The iterator returns two-tuples of (node, out-degree).</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.degree" title="specless.automaton.pdfa.PDFA.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_degree" title="specless.automaton.pdfa.PDFA.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (1, 1), (2, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># parallel edge</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span> <span class="c1"># counts parallel edges</span>
<span class="go">[(0, 2), (1, 1), (2, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.out_edges">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_edges</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.out_edges" title="Link to this definition">¶</a></dt>
<dd><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p>
<p>edges(self, nbunch=None, data=False, keys=False, default=None)</p>
<p>The OutMultiEdgeView provides set-like operations on the edge-tuples
as well as edge attribute lookup. When called, it also provides
an EdgeDataView object which allows control of access to edge
attributes (but does not provide set-like operations).
Hence, <code class="docutils literal notranslate"><span class="pre">G.edges[u,</span> <span class="pre">v,</span> <span class="pre">k]['color']</span></code> provides the value of the color
attribute for the edge from <code class="docutils literal notranslate"><span class="pre">u</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code> with key <code class="docutils literal notranslate"><span class="pre">k</span></code> while
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">k,</span> <span class="pre">c)</span> <span class="pre">in</span> <span class="pre">G.edges(data='color',</span> <span class="pre">default='red',</span> <span class="pre">keys=True):</span></code>
iterates through all the edges yielding the color attribute with
default <cite>‘red’</cite> if no color attribute exists.</p>
<p>Edges are returned as tuples with optional data and keys
in the order (node, neighbor, key, data). If <code class="docutils literal notranslate"><span class="pre">keys=True</span></code> is not
provided, the tuples will just be (node, neighbor, data), but
multiple tuples with the same node and neighbor will be
generated when multiple edges between two nodes exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nbunch</strong> (<em>single node</em><em>, </em><em>container</em><em>, or </em><em>all nodes</em><em> (</em><em>default= all nodes</em><em>)</em>) – The view will only report edges from these nodes.</p></li>
<li><p><strong>data</strong> (<em>string</em><em> or </em><em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – The edge attribute returned in 3-tuple (u, v, ddict[data]).
If True, return edge attribute dict in 3-tuple (u, v, ddict).
If False, return 2-tuple (u, v).</p></li>
<li><p><strong>keys</strong> (<em>bool</em><em>, </em><em>optional</em><em> (</em><em>default=False</em><em>)</em>) – If True, return edge keys with each edge, creating (u, v, k,
d) tuples when data is also requested (the default) and (u,
v, k) tuples when data is not requested.</p></li>
<li><p><strong>default</strong> (<em>value</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Value used for edges that don’t have the requested attribute.
Only relevant if data is not True or False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>edges</strong> – A view of edge attributes, usually it iterates over (u, v)
(u, v, k) or (u, v, k, d) tuples of edges, but can also be
used for attribute lookup as <code class="docutils literal notranslate"><span class="pre">edges[u,</span> <span class="pre">v,</span> <span class="pre">k]['foo']</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>OutMultiEdgeView</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Nodes in nbunch that are not in the graph will be (quietly) ignored.
For directed graphs this returns the out-edges.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># second edge between these nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="go">[(0, 1), (1, 2), (1, 2), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default data is {} (empty dict)</span>
<span class="go">[(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default keys are integers</span>
<span class="go">[(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_edges" title="specless.automaton.pdfa.PDFA.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_edges" title="specless.automaton.pdfa.PDFA.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.perplexity">
<span class="sig-name descname"><span class="pre">perplexity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.perplexity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.perplexity" title="Link to this definition">¶</a></dt>
<dd><p>computes actual perplexity of the given traces in the language of
the PDFA on the given actual trace probabilities</p>
<p>References:
Speech and Language Processing (SLP), 3 ed., Ch3
(<a class="reference external" href="https://web.stanford.edu/~jurafsky/slp3/3.pdf">https://web.stanford.edu/~jurafsky/slp3/3.pdf</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – The list of sequences of symbols to
evaluate the model’s actual cross
entropy on.</p></li>
<li><p><strong>actual_trace_probs</strong> – The actual probability of each trace
in the target language distribution</p></li>
<li><p><strong>base</strong> – The log base. Commonly set to 2 in
classic information theory literature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the actual cross-entropy of the given trace</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.perplexity_approx">
<span class="sig-name descname"><span class="pre">perplexity_approx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.perplexity_approx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.perplexity_approx" title="Link to this definition">¶</a></dt>
<dd><p>computes approximate perplexity of the given trace in the language of
the PDFA</p>
<p>The approximate perplexity is based on computing the approximate
cross-entropy (cross_entropy_approximate) (eq. 3.52 of SLP).</p>
<p>References:
NLTK.lm.api
Speech and Language Processing (SLP), 3 ed., Ch3
(<a class="reference external" href="https://web.stanford.edu/~jurafsky/slp3/3.pdf">https://web.stanford.edu/~jurafsky/slp3/3.pdf</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trace</strong> – The sequence of symbols to evaluate</p></li>
<li><p><strong>base</strong> – The log base used for log probability calculations
of the approximate cross-entropy underpinning the
perplexity. Commonly set to 2 in classic
information theory literature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the approximate perplexity of the given trace</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.plot_node_trans_dist">
<span class="sig-name descname"><span class="pre">plot_node_trans_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curr_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Hashable</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.plot_node_trans_dist" title="Link to this definition">¶</a></dt>
<dd><p>Plots the transition pmf at the given curr_state / node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>curr_state</strong> (<em>Hashable</em>) – state to display its transition distribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.pred">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pred</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.pred" title="Link to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the predecessors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <cite>G.adj[3][2][0][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2, 0)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.predecessors">
<span class="sig-name descname"><span class="pre">predecessors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.predecessors" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator over predecessor nodes of n.</p>
<p>A predecessor of n is a node m such that there exists a directed
edge from m to n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>node</em>) – A node in the graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If n is not in the graph.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.successors" title="specless.automaton.pdfa.PDFA.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symbols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'max_prob'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Hashable</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.predict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.predict" title="Link to this definition">¶</a></dt>
<dd><p>predicts the next symbol conditioned on the given previous symbols</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>symbols</strong> – The previously observed emitted symbols</p></li>
<li><p><strong>pred_method</strong> – The method used to choose the next state. see
_choose_next_state for details on how each
pred_method is implemented.
{‘sample’, ‘max_prob’}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the most probable next symbol in the sequence</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.predictive_accuracy">
<span class="sig-name descname"><span class="pre">predictive_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'max_prob'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.predictive_accuracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.predictive_accuracy" title="Link to this definition">¶</a></dt>
<dd><p>compares the model’s predictions to the actual values of the next
symbol and returns the ratio of correct predictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_traces</strong> – The traces to compute predictive accuracy for</p></li>
<li><p><strong>pred_method</strong> – The method used to choose the next state.
see _choose_next_state for details on how
each pred_method is implemented.
{‘sample’, ‘max_prob’}</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>predictive accuracy ratio ([0 -&gt; 1]) of the model on the
given traces</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.remove_edge" title="Link to this definition">¶</a></dt>
<dd><p>Remove an edge between u and v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>nodes</em>) – Remove an edge between nodes u and v.</p></li>
<li><p><strong>v</strong> (<em>nodes</em>) – Remove an edge between nodes u and v.</p></li>
<li><p><strong>key</strong> (<em>hashable identifier</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Used to distinguish multiple edges between a pair of nodes.
If None, remove a single edge between u and v. If there are
multiple edges, removes the last edge added in terms of
insertion order.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If there is not an edge between u and v, or
    if there is no edge with the specified key.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edges_from" title="specless.automaton.pdfa.PDFA.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a></dt><dd><p>remove a collection of edges</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># unpacks e from an edge tuple</span>
</pre></div>
</div>
<p>For multiple edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># key_list returned</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">key=None</span></code> (the default), edges are removed in the opposite
order that they were added:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">OutMultiEdgeView([(1, 2, 0), (1, 2, 1)])</span>
</pre></div>
</div>
<p>For edges with keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
<span class="go">&#39;first&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;second&quot;</span><span class="p">)</span>
<span class="go">&#39;second&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">OutMultiEdgeView([(1, 2, &#39;second&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.remove_edges_from">
<span class="sig-name descname"><span class="pre">remove_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.remove_edges_from" title="Link to this definition">¶</a></dt>
<dd><p>Remove all edges specified in ebunch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ebunch</strong> (<em>list</em><em> or </em><em>container</em><em> of </em><em>edge tuples</em>) – <p>Each edge given in the list or container will be removed
from the graph. The edges can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>2-tuples (u, v) A single edge between u and v is removed.</p></li>
<li><p>3-tuples (u, v, key) The edge identified by key is removed.</p></li>
<li><p>4-tuples (u, v, key, data) where data is ignored.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edge" title="specless.automaton.pdfa.PDFA.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a></dt><dd><p>remove a single edge</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Will fail silently if an edge in ebunch is not in the graph.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebunch</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
</pre></div>
</div>
<p>Removing multiple copies of edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>  <span class="c1"># edges aren&#39;t directed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">[(1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># silently ignore extra copy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>  <span class="c1"># now empty graph</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>When the edge is a 2-tuple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> but there are multiple edges between
u and v in the graph, the most recent edge (in terms of insertion
order) is removed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">k</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">MultiEdgeView([(0, 1, &#39;x&#39;), (0, 1, &#39;y&#39;), (0, 1, &#39;a&#39;)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">MultiEdgeView([(0, 1, &#39;x&#39;), (0, 1, &#39;y&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.remove_node">
<span class="sig-name descname"><span class="pre">remove_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.remove_node" title="Link to this definition">¶</a></dt>
<dd><p>Remove node n.</p>
<p>Removes the node n and all adjacent edges.
Attempting to remove a nonexistent node will raise an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>node</em>) – A node in the graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If n is not in the graph.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_nodes_from" title="specless.automaton.pdfa.PDFA.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.remove_nodes_from">
<span class="sig-name descname"><span class="pre">remove_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.remove_nodes_from" title="Link to this definition">¶</a></dt>
<dd><p>Remove multiple nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nodes</strong> (<em>iterable container</em>) – A container of nodes (list, dict, set, etc.).  If a node
in the container is not in the graph it is silently ignored.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_node" title="specless.automaton.pdfa.PDFA.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>When removing nodes from an iterator over the graph you are changing,
a <cite>RuntimeError</cite> will be raised with message:
<cite>RuntimeError: dictionary changed size during iteration</cite>. This
happens when the graph’s underlying dictionary is modified during
iteration. To avoid this error, evaluate the iterator into a separate
object, e.g. by using <cite>list(iterator_of_nodes)</cite>, and pass this
object to <cite>G.remove_nodes_from</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Evaluate an iterator over a graph if using it to modify the same graph</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this command will fail, as the graph&#39;s dict is modified during iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># G.remove_nodes_from(n for n in G.nodes if n &lt; 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this command will work, since the dictionary underlying graph is not modified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.reverse">
<span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.reverse" title="Link to this definition">¶</a></dt>
<dd><p>Returns the reverse of the graph.</p>
<p>The reverse is a graph with the same nodes and edges
but with the directions of the edges reversed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>copy</strong> (<em>bool optional</em><em> (</em><em>default=True</em><em>)</em>) – If True, return a new DiGraph holding the reversed edges.
If False, the reverse graph is created using a view of
the original graph.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.reverse_kldivergence">
<span class="sig-name descname"><span class="pre">reverse_kldivergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">actual_trace_probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.reverse_kldivergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.reverse_kldivergence" title="Link to this definition">¶</a></dt>
<dd><p>Reverse KL Divergence
Use ReverseKL on traces generated by other automaton</p>
<p>KL(q||p) =  q log(q) - q log(p)</p>
<p>where p is the true probability and q is the estimated probability
p must not be 0 otherwise the KL divergence goes to infinity.
Therefore, we must be certain that the traces were generated by
the true automaton, so that p is always positive p&gt;0</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.score">
<span class="sig-name descname"><span class="pre">score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.score" title="Link to this definition">¶</a></dt>
<dd><p>Calculates the given trace’s probability in the language of the PDFA.</p>
<dl class="simple">
<dt>PDFA is a language model (LM) in this case:</dt><dd><p>==&gt; score = P_{PDFA LM}(trace)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trace</strong> – A trace</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A trace probability</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.scores">
<span class="sig-name descname"><span class="pre">scores</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">traces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/specless/automaton/pdfa.html#PDFA.scores"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#specless.automaton.pdfa.PDFA.scores" title="Link to this definition">¶</a></dt>
<dd><p>Calculates trace probabilities</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trace</strong> – A list of traces</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The trace probability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.size" title="Link to this definition">¶</a></dt>
<dd><p>Returns the number of edges or total of all edge weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weight</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – The edge attribute that holds the numerical value used
as a weight. If None, then each edge has weight 1.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>size</strong> – The number of edges or
(if weight keyword is provided) the total weight sum.</p>
<p>If weight is None, returns an int. Otherwise a float
(or more general numeric if the weights are more general).</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numeric</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_edges" title="specless.automaton.pdfa.PDFA.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
<span class="go">6.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.start_state">
<span class="sig-name descname"><span class="pre">start_state</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.start_state" title="Link to this definition">¶</a></dt>
<dd><p>unique start state string label of automaton</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.state_labels">
<span class="sig-name descname"><span class="pre">state_labels</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.state_labels" title="Link to this definition">¶</a></dt>
<dd><p>set of all states in the automaton</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.subgraph">
<span class="sig-name descname"><span class="pre">subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.subgraph" title="Link to this definition">¶</a></dt>
<dd><p>Returns a SubGraph view of the subgraph induced on <cite>nodes</cite>.</p>
<p>The induced subgraph of the graph contains the nodes in <cite>nodes</cite>
and the edges between those nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nodes</strong> (<em>list</em><em>, </em><em>iterable</em>) – A container of nodes which will be iterated through once.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – A subgraph view of the graph. The graph structure cannot be
changed but node/edge attributes can and are shared with the
original graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SubGraph View</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The graph, edge and node attributes are shared with the original graph.
Changes to the graph structure is ruled out by the view, but changes
to attributes are reflected in the original graph.</p>
<p>To create a subgraph with its own copy of the edge/node attributes use:
G.subgraph(nodes).copy()</p>
<p>For an inplace reduction of a graph to a subgraph you can remove nodes:
G.remove_nodes_from([n for n in G if n not in set(nodes)])</p>
<p>Subgraph views are sometimes NOT what you want. In most cases where
you want to do more than simply look at the induced edges, it makes
more sense to just create the subgraph as its own graph with code like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a subgraph SG based on a (possibly multigraph) G</span>
<span class="n">SG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
<span class="n">SG</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span><span class="p">)</span>
<span class="k">if</span> <span class="n">SG</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
    <span class="n">SG</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">keydict</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">keydict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">SG</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">largest_wcc</span><span class="p">)</span>
<span class="n">SG</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.succ">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">succ</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.succ" title="Link to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the successors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <cite>G.adj[3][2][0][‘color’] = ‘blue’</cite> sets
the color of the edge <cite>(3, 2, 0)</cite> to <cite>“blue”</cite>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<cite>for nbr, datadict in G.adj[n].items():</cite>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <cite>for nbr, foovalue in G[node].data(‘foo’, default=1):</cite> works.</p>
<p>For directed graphs, <cite>G.succ</cite> is identical to <cite>G.adj</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.successors">
<span class="sig-name descname"><span class="pre">successors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.successors" title="Link to this definition">¶</a></dt>
<dd><p>Returns an iterator over successor nodes of n.</p>
<p>A successor of n is a node m such that there exists a directed
edge from n to m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>node</em>) – A node in the graph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NetworkXError</strong> – If n is not in the graph.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predecessors" title="specless.automaton.pdfa.PDFA.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>neighbors() and successors() are the same.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.symbols">
<span class="sig-name descname"><span class="pre">symbols</span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.symbols" title="Link to this definition">¶</a></dt>
<dd><p>set of all symbols used by the automaton</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.to_directed">
<span class="sig-name descname"><span class="pre">to_directed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.to_directed" title="Link to this definition">¶</a></dt>
<dd><p>Returns a directed representation of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>G</strong> – A directed graph with the same name, same nodes, and with
each edge (u, v, k, data) replaced by two directed edges
(u, v, k, data) and (v, u, k, data).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>MultiDiGraph</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This returns a “deepcopy” of the edge, node, and
graph attributes which attempts to completely copy
all of the data and references.</p>
<p>This is in contrast to the similar D=MultiDiGraph(G) which
returns a shallow copy of the data.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<p>Warning: If you have subclassed MultiGraph to use dict-like objects
in the data structure, those changes do not transfer to the
MultiDiGraph created by this method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]</span>
</pre></div>
</div>
<p>If already directed, return a (deep) copy</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.to_directed_class">
<span class="sig-name descname"><span class="pre">to_directed_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.to_directed_class" title="Link to this definition">¶</a></dt>
<dd><p>Returns the class to use for empty directed copies.</p>
<p>If you subclass the base classes, use this to designate
what directed class to use for <cite>to_directed()</cite> copies.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.to_undirected">
<span class="sig-name descname"><span class="pre">to_undirected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reciprocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.to_undirected" title="Link to this definition">¶</a></dt>
<dd><p>Returns an undirected representation of the digraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reciprocal</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – If True only keep edges that appear in both directions
in the original digraph.</p></li>
<li><p><strong>as_view</strong> (<em>bool</em><em> (</em><em>optional</em><em>, </em><em>default=False</em><em>)</em>) – If True return an undirected view of the original directed graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>G</strong> – An undirected graph with the same name and nodes and
with edge (u, v, data) if either (u, v, data) or (v, u, data)
is in the digraph.  If both edges exist in digraph and
their edge data is different, only one edge is created
with an arbitrary choice of which edge data to use.
You must check and correct for this manually if desired.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>MultiGraph</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiGraph</span></code>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.copy" title="specless.automaton.pdfa.PDFA.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edge" title="specless.automaton.pdfa.PDFA.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a>, <a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="specless.automaton.pdfa.PDFA.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This returns a “deepcopy” of the edge, node, and
graph attributes which attempts to completely copy
all of the data and references.</p>
<p>This is in contrast to the similar D=MultiDiGraph(G) which
returns a shallow copy of the data.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<p>Warning: If you have subclassed MultiDiGraph to use dict-like
objects in the data structure, those changes do not transfer
to the MultiGraph created by this method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># or MultiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G2</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.to_undirected_class">
<span class="sig-name descname"><span class="pre">to_undirected_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.to_undirected_class" title="Link to this definition">¶</a></dt>
<dd><p>Returns the class to use for empty undirected copies.</p>
<p>If you subclass the base classes, use this to designate
what directed class to use for <cite>to_directed()</cite> copies.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.update" title="Link to this definition">¶</a></dt>
<dd><p>Update the graph using nodes/edges/graphs as input.</p>
<p>Like dict.update, this method takes a graph as input, adding the
graph’s nodes and edges to this graph. It can also take two inputs:
edges and nodes. Finally it can take either edges or nodes.
To specify only nodes the keyword <cite>nodes</cite> must be used.</p>
<p>The collections of edges and nodes are treated similarly to
the add_edges_from/add_nodes_from methods. When iterated, they
should yield 2-tuples (u, v) or 3-tuples (u, v, datadict).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> (<em>Graph object</em><em>, </em><em>collection</em><em> of </em><em>edges</em><em>, or </em><em>None</em>) – The first parameter can be a graph or some edges. If it has
attributes <cite>nodes</cite> and <cite>edges</cite>, then it is taken to be a
Graph-like object and those attributes are used as collections
of nodes and edges to be added to the graph.
If the first parameter does not have those attributes, it is
treated as a collection of edges and added to the graph.
If the first argument is None, no edges are added.</p></li>
<li><p><strong>nodes</strong> (<em>collection</em><em> of </em><em>nodes</em><em>, or </em><em>None</em>) – The second parameter is treated as a collection of nodes
to be added to the graph unless it is None.
If <cite>edges is None</cite> and <cite>nodes is None</cite> an exception is raised.
If the first parameter is a Graph, then <cite>nodes</cite> is ignored.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;power&quot;</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">225</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">]</span>  <span class="c1"># for singleton, use a container</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>It you want to update the graph using an adjacency structure
it is straightforward to obtain the edges/nodes from adjacency.
The following examples provide common cases, your adjacency may
be slightly different and require tweaks of these examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-set/list/tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-dict-of-attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">1.4</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-dict-of-dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># predecessor adjacency (dict-of-set)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">pred</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># MultiGraph dict-of-dict-of-dict-of-attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MDG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">}}},</span>
<span class="gp">... </span>    <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">}}},</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">keydict</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">keydict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MDG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from" title="specless.automaton.pdfa.PDFA.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add multiple edges to a graph</p>
</dd>
<dt><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_nodes_from" title="specless.automaton.pdfa.PDFA.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></dt><dd><p>add multiple nodes to a graph</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="specless.automaton.pdfa.PDFA.write_traces_to_file">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">write_traces_to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">traces:</span> <span class="pre">~typing.List[~typing.Iterable[~typing.Hashable]],</span> <span class="pre">file:</span> <span class="pre">str,</span> <span class="pre">alphabet_size:</span> <span class="pre">int,</span> <span class="pre">base_file_dir:</span> <span class="pre">{None,</span> <span class="pre">&lt;class</span> <span class="pre">'str'&gt;}</span> <span class="pre">=</span> <span class="pre">None</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#specless.automaton.pdfa.PDFA.write_traces_to_file" title="Link to this definition">¶</a></dt>
<dd><p>Writes trace samples to a file in the abbadingo format for use in
grammatical inference tools like flexfringe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traces</strong> – The traces to write to a file</p></li>
<li><p><strong>file</strong> – The file name to write to. Can be a partial
path.</p></li>
<li><p><strong>alphabet_size</strong> – The alphabet size</p></li>
<li><p><strong>base_file_dir</strong> – Provide this if you want to output the file
to a different location than
self.automata_data_dir.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the absolute filepath to the traces. Will be:
abs_filepath(self.automata_data_dir/file) if base_file_dir
is None. Else, will be: abs_filepath(base_file_dir/file)</p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">specless</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="specless.html">specless</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="specless.automaton.html">specless.automaton</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.base.html">specless.automaton.base</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.dfa.html">specless.automaton.dfa</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.factory.html">specless.automaton.factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.fdfa.html">specless.automaton.fdfa</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.mps.html">specless.automaton.mps</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="specless.automaton.pdfa.html">specless.automaton.pdfa</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="specless.automaton.pdfa.check_predict_method.html">specless.automaton.pdfa.check_predict_method</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">specless.automaton.pdfa.PDFA</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#specless.automaton.pdfa.PDFA"><code class="docutils literal notranslate"><span class="pre">PDFA</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edge"><code class="docutils literal notranslate"><span class="pre">PDFA.add_edge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_edges_from"><code class="docutils literal notranslate"><span class="pre">PDFA.add_edges_from()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_node"><code class="docutils literal notranslate"><span class="pre">PDFA.add_node()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_nodes_from"><code class="docutils literal notranslate"><span class="pre">PDFA.add_nodes_from()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.add_weighted_edges_from"><code class="docutils literal notranslate"><span class="pre">PDFA.add_weighted_edges_from()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adj"><code class="docutils literal notranslate"><span class="pre">PDFA.adj</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adjacency"><code class="docutils literal notranslate"><span class="pre">PDFA.adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adjlist_inner_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.adjlist_inner_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.adjlist_outer_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.adjlist_outer_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.alphabet_size"><code class="docutils literal notranslate"><span class="pre">PDFA.alphabet_size</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.average_norm"><code class="docutils literal notranslate"><span class="pre">PDFA.average_norm()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.clear"><code class="docutils literal notranslate"><span class="pre">PDFA.clear()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.clear_edges"><code class="docutils literal notranslate"><span class="pre">PDFA.clear_edges()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.copy"><code class="docutils literal notranslate"><span class="pre">PDFA.copy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.cross_entropy"><code class="docutils literal notranslate"><span class="pre">PDFA.cross_entropy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.cross_entropy_approx"><code class="docutils literal notranslate"><span class="pre">PDFA.cross_entropy_approx()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.degree"><code class="docutils literal notranslate"><span class="pre">PDFA.degree</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.disp_edges"><code class="docutils literal notranslate"><span class="pre">PDFA.disp_edges()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.disp_nodes"><code class="docutils literal notranslate"><span class="pre">PDFA.disp_nodes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.draw"><code class="docutils literal notranslate"><span class="pre">PDFA.draw()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edge_attr_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.edge_attr_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edge_key_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.edge_key_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edge_subgraph"><code class="docutils literal notranslate"><span class="pre">PDFA.edge_subgraph()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.edges"><code class="docutils literal notranslate"><span class="pre">PDFA.edges</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.empty_transition_sym"><code class="docutils literal notranslate"><span class="pre">PDFA.empty_transition_sym</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.final_transition_sym"><code class="docutils literal notranslate"><span class="pre">PDFA.final_transition_sym</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.generate_trace"><code class="docutils literal notranslate"><span class="pre">PDFA.generate_trace()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.generate_traces"><code class="docutils literal notranslate"><span class="pre">PDFA.generate_traces()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.get_edge_data"><code class="docutils literal notranslate"><span class="pre">PDFA.get_edge_data()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.graph_attr_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.graph_attr_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_edge"><code class="docutils literal notranslate"><span class="pre">PDFA.has_edge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_node"><code class="docutils literal notranslate"><span class="pre">PDFA.has_node()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_predecessor"><code class="docutils literal notranslate"><span class="pre">PDFA.has_predecessor()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.has_successor"><code class="docutils literal notranslate"><span class="pre">PDFA.has_successor()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_degree"><code class="docutils literal notranslate"><span class="pre">PDFA.in_degree</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.in_edges"><code class="docutils literal notranslate"><span class="pre">PDFA.in_edges</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_deterministic"><code class="docutils literal notranslate"><span class="pre">PDFA.is_deterministic</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_directed"><code class="docutils literal notranslate"><span class="pre">PDFA.is_directed()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_multigraph"><code class="docutils literal notranslate"><span class="pre">PDFA.is_multigraph()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_normalized"><code class="docutils literal notranslate"><span class="pre">PDFA.is_normalized</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_sampleable"><code class="docutils literal notranslate"><span class="pre">PDFA.is_sampleable</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.is_stochastic"><code class="docutils literal notranslate"><span class="pre">PDFA.is_stochastic</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.kldivergence"><code class="docutils literal notranslate"><span class="pre">PDFA.kldivergence()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.logscore"><code class="docutils literal notranslate"><span class="pre">PDFA.logscore()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.logscores"><code class="docutils literal notranslate"><span class="pre">PDFA.logscores()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.mdi_score"><code class="docutils literal notranslate"><span class="pre">PDFA.mdi_score()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.most_probable_string"><code class="docutils literal notranslate"><span class="pre">PDFA.most_probable_string()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.name"><code class="docutils literal notranslate"><span class="pre">PDFA.name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.nbunch_iter"><code class="docutils literal notranslate"><span class="pre">PDFA.nbunch_iter()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.neighbors"><code class="docutils literal notranslate"><span class="pre">PDFA.neighbors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.new_edge_key"><code class="docutils literal notranslate"><span class="pre">PDFA.new_edge_key()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.node_attr_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.node_attr_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.node_dict_factory"><code class="docutils literal notranslate"><span class="pre">PDFA.node_dict_factory</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.nodes"><code class="docutils literal notranslate"><span class="pre">PDFA.nodes</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.norm"><code class="docutils literal notranslate"><span class="pre">PDFA.norm()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.num_obs"><code class="docutils literal notranslate"><span class="pre">PDFA.num_obs</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.num_states"><code class="docutils literal notranslate"><span class="pre">PDFA.num_states</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_edges"><code class="docutils literal notranslate"><span class="pre">PDFA.number_of_edges()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.number_of_nodes"><code class="docutils literal notranslate"><span class="pre">PDFA.number_of_nodes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.observations"><code class="docutils literal notranslate"><span class="pre">PDFA.observations</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.observe"><code class="docutils literal notranslate"><span class="pre">PDFA.observe()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.order"><code class="docutils literal notranslate"><span class="pre">PDFA.order()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_degree"><code class="docutils literal notranslate"><span class="pre">PDFA.out_degree</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.out_edges"><code class="docutils literal notranslate"><span class="pre">PDFA.out_edges</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.perplexity"><code class="docutils literal notranslate"><span class="pre">PDFA.perplexity()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.perplexity_approx"><code class="docutils literal notranslate"><span class="pre">PDFA.perplexity_approx()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.plot_node_trans_dist"><code class="docutils literal notranslate"><span class="pre">PDFA.plot_node_trans_dist()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.pred"><code class="docutils literal notranslate"><span class="pre">PDFA.pred</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predecessors"><code class="docutils literal notranslate"><span class="pre">PDFA.predecessors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predict"><code class="docutils literal notranslate"><span class="pre">PDFA.predict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.predictive_accuracy"><code class="docutils literal notranslate"><span class="pre">PDFA.predictive_accuracy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edge"><code class="docutils literal notranslate"><span class="pre">PDFA.remove_edge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_edges_from"><code class="docutils literal notranslate"><span class="pre">PDFA.remove_edges_from()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_node"><code class="docutils literal notranslate"><span class="pre">PDFA.remove_node()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.remove_nodes_from"><code class="docutils literal notranslate"><span class="pre">PDFA.remove_nodes_from()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.reverse"><code class="docutils literal notranslate"><span class="pre">PDFA.reverse()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.reverse_kldivergence"><code class="docutils literal notranslate"><span class="pre">PDFA.reverse_kldivergence()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.score"><code class="docutils literal notranslate"><span class="pre">PDFA.score()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.scores"><code class="docutils literal notranslate"><span class="pre">PDFA.scores()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.size"><code class="docutils literal notranslate"><span class="pre">PDFA.size()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.start_state"><code class="docutils literal notranslate"><span class="pre">PDFA.start_state</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.state_labels"><code class="docutils literal notranslate"><span class="pre">PDFA.state_labels</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.subgraph"><code class="docutils literal notranslate"><span class="pre">PDFA.subgraph()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.succ"><code class="docutils literal notranslate"><span class="pre">PDFA.succ</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.successors"><code class="docutils literal notranslate"><span class="pre">PDFA.successors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.symbols"><code class="docutils literal notranslate"><span class="pre">PDFA.symbols</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_directed"><code class="docutils literal notranslate"><span class="pre">PDFA.to_directed()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_directed_class"><code class="docutils literal notranslate"><span class="pre">PDFA.to_directed_class()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_undirected"><code class="docutils literal notranslate"><span class="pre">PDFA.to_undirected()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.to_undirected_class"><code class="docutils literal notranslate"><span class="pre">PDFA.to_undirected_class()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.update"><code class="docutils literal notranslate"><span class="pre">PDFA.update()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="#specless.automaton.pdfa.PDFA.write_traces_to_file"><code class="docutils literal notranslate"><span class="pre">PDFA.write_traces_to_file()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="specless.automaton.pdfa.PDFABuilder.html">specless.automaton.pdfa.PDFABuilder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.product.html">specless.automaton.product</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.transition_system.html">specless.automaton.transition_system</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.types.html">specless.automaton.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="specless.automaton.utils.html">specless.automaton.utils</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="specless.cli.html">specless.cli</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.const.html">specless.const</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.dataset.html">specless.dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.factory.html">specless.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.inference.html">specless.inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.io.html">specless.io</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.parser.html">specless.parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.specification.html">specless.specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.specification_.html">specless.specification_</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.strategy.html">specless.strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.synthesis.html">specless.synthesis</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.typing.html">specless.typing</a></li>
<li class="toctree-l2"><a class="reference internal" href="specless.wrapper.html">specless.wrapper</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="specless.html">specless</a><ul>
  <li><a href="specless.automaton.html">specless.automaton</a><ul>
  <li><a href="specless.automaton.pdfa.html">specless.automaton.pdfa</a><ul>
      <li>Previous: <a href="specless.automaton.pdfa.check_predict_method.html" title="previous chapter">specless.automaton.pdfa.check_predict_method</a></li>
      <li>Next: <a href="specless.automaton.pdfa.PDFABuilder.html" title="next chapter">specless.automaton.pdfa.PDFABuilder</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2023, Kandai Watanabe.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/_autosummary/specless.automaton.pdfa.PDFA.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>