<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>specless.automaton.base &mdash; specless 0.0.2 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=e3a6060d"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            specless
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/specless.html">specless</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">specless</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">specless.automaton.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for specless.automaton.base</h1><div class="highlight"><pre>
<span></span><span class="c1"># 3rd-party packages</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">graphviz</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">bidict</span> <span class="kn">import</span> <span class="n">bidict</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">networkx.drawing.nx_pydot</span> <span class="kn">import</span> <span class="n">to_pydot</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">RandomState</span>
<span class="kn">from</span> <span class="nn">pydot</span> <span class="kn">import</span> <span class="n">Dot</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rv_discrete</span>

<span class="kn">from</span> <span class="nn">.mps</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SWDFA_MPS</span><span class="p">,</span>
    <span class="n">BMPS_exact</span><span class="p">,</span>
    <span class="n">MPSReturnData</span><span class="p">,</span>
    <span class="n">postprocess_MPS</span><span class="p">,</span>
    <span class="n">should_use_BMPS_exact</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># local packages / modules</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GeneratedTraceData</span><span class="p">,</span>
    <span class="n">Node</span><span class="p">,</span>
    <span class="n">Nodes</span><span class="p">,</span>
    <span class="n">NXEdgeList</span><span class="p">,</span>
    <span class="n">NXNodeList</span><span class="p">,</span>
    <span class="n">Observation</span><span class="p">,</span>
    <span class="n">Probabilities</span><span class="p">,</span>
    <span class="n">Probability</span><span class="p">,</span>
    <span class="n">SampledTransData</span><span class="p">,</span>
    <span class="n">Symbol</span><span class="p">,</span>
    <span class="n">Symbols</span><span class="p">,</span>
    <span class="n">Trans_data</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># needed for multi-threaded sampling routine</span>
<span class="n">NUM_CORES</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>

<span class="c1"># constants</span>
<span class="n">SMOOTHING_AMOUNT</span> <span class="o">=</span> <span class="mf">0.0001</span>
<span class="n">DEFAULT_FINAL_TRANS_SYMBOL</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span>
<span class="n">DEFAULT_EMPTY_TRANS_SYMBOL</span> <span class="o">=</span> <span class="s2">&quot;lambda&quot;</span>


<div class="viewcode-block" id="Automaton">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton">[docs]</a>
<span class="k">class</span> <span class="nc">Automaton</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class describes a automaton with (possibly) stochastic transitions</span>

<span class="sd">    built on networkx, so inherits node and edge data structure definitions</span>

<span class="sd">    Node Attributes</span>
<span class="sd">    -----------------</span>
<span class="sd">        - final_probability: final state probability for the node</span>
<span class="sd">        - trans_distribution: a sampled-able function to select the next state</span>
<span class="sd">          and emitted symbol</span>
<span class="sd">        - is_accepting: a boolean flag determining whether the automaton</span>
<span class="sd">          considers the node accepting</span>

<span class="sd">    Edge Properties</span>
<span class="sd">    -----------------</span>
<span class="sd">        - symbol: the symbol value emitted when the edge is traversed</span>
<span class="sd">        - probability: the probability of selecting this edge for traversal</span>

<span class="sd">    :param      nodes:                     node list as expected by</span>
<span class="sd">                                           networkx.add_nodes_from()</span>
<span class="sd">    :param      edge_list:                 edge list as expected by</span>
<span class="sd">                                           networkx.add_edges_from()</span>
<span class="sd">    :param      symbol_display_map:        bidirectional mapping of</span>
<span class="sd">                                           hashable symbols, to a unique</span>
<span class="sd">                                           integer index in the symbol map.</span>
<span class="sd">                                           Needed to translate between the</span>
<span class="sd">                                           indices in the transition</span>
<span class="sd">                                           distribution and the hashable</span>
<span class="sd">                                           representation which is</span>
<span class="sd">                                           meaningful to the user</span>
<span class="sd">    :param      alphabet_size:             number of symbols in automaton</span>
<span class="sd">    :param      num_states:                number of states in automaton</span>
<span class="sd">                                           state space</span>
<span class="sd">    :param      start_state:               unique start state string label</span>
<span class="sd">                                           of automaton</span>
<span class="sd">    :param      smooth_transitions:        whether to smooth the symbol</span>
<span class="sd">                                           transitions distributions</span>
<span class="sd">    :param      is_stochastic:             the transitions are</span>
<span class="sd">                                           non-probabilistic, so we are</span>
<span class="sd">                                           going to assign a uniform</span>
<span class="sd">                                           distribution over all symbols</span>
<span class="sd">                                           for the purpose of generation</span>
<span class="sd">    :param      is_sampleable:             will formalize / create probability</span>
<span class="sd">                                           distributions for each state&#39;s</span>
<span class="sd">                                           transitions to allow for sampling of</span>
<span class="sd">                                           runs from the machine</span>
<span class="sd">    :param      is_normalized:             whether the</span>
<span class="sd">                                           edge probabilities are renormalize</span>
<span class="sd">                                           such that each states has a well-</span>
<span class="sd">                                           defined transition</span>
<span class="sd">                                           probability distribution.</span>
<span class="sd">                                           We typically DONT want to</span>
<span class="sd">                                           modify the probabilities,</span>
<span class="sd">                                           except if we would like</span>
<span class="sd">                                           to be able to sample traces</span>
<span class="sd">    :param      num_obs:                   number of observation symbols</span>
<span class="sd">    :param      final_transition_sym:      representation of the</span>
<span class="sd">                                           termination symbol</span>
<span class="sd">    :param      empty_transition_sym:      representation of the empty</span>
<span class="sd">                                           symbol (a.k.a. lambda)</span>
<span class="sd">    :param      initial_weight_key:        key in the automaton&#39;s node data</span>
<span class="sd">                                           corresponding to the weight /</span>
<span class="sd">                                           probability of starting in that</span>
<span class="sd">                                           node. If None, don&#39;t include</span>
<span class="sd">                                           this info in the display of the</span>
<span class="sd">                                           automaton.</span>
<span class="sd">    :param      final_weight_key:          key in the automaton&#39;s node data</span>
<span class="sd">                                           corresponding to the weight /</span>
<span class="sd">                                           probability of ending in that</span>
<span class="sd">                                           node. If None, don&#39;t include</span>
<span class="sd">                                           this info in the display of the</span>
<span class="sd">                                           automaton.</span>
<span class="sd">    :param      state_observation_key:     The key in each node&#39;s data dict</span>
<span class="sd">                                           for state observations. If None,</span>
<span class="sd">                                           don&#39;t include this info in the</span>
<span class="sd">                                           display of the automaton</span>
<span class="sd">    :param      can_have_accepting_nodes:  Indicates if the automata can</span>
<span class="sd">                                           have accepting nodes</span>
<span class="sd">    :param      merge_sinks:               whether to combine all states</span>
<span class="sd">                                           together that have no outgoing edges</span>
<span class="sd">    :param      edge_weight_key:           The key in each edge&#39;s data dict</span>
<span class="sd">                                           for edge weight / prob. If None,</span>
<span class="sd">                                           don&#39;t include this info in the</span>
<span class="sd">                                           display of the automaton</span>
<span class="sd">    :param      smoothing_amount:          probability mass to re-assign to</span>
<span class="sd">                                           unseen symbols at each node</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># file I/O</span>
    <span class="n">automata_display_data_dir_name</span> <span class="o">=</span> <span class="s2">&quot;automata_images&quot;</span>
    <span class="n">automata_data_dir</span> <span class="o">=</span> <span class="s2">&quot;automaton_data&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">NXNodeList</span><span class="p">,</span>
        <span class="n">edge_list</span><span class="p">:</span> <span class="n">NXEdgeList</span><span class="p">,</span>
        <span class="n">symbol_display_map</span><span class="p">:</span> <span class="n">bidict</span><span class="p">,</span>
        <span class="n">alphabet_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_states</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start_state</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">smooth_transitions</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_stochastic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_sampleable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">is_normalized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">num_obs</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">final_transition_sym</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">DEFAULT_FINAL_TRANS_SYMBOL</span><span class="p">,</span>
        <span class="n">empty_transition_sym</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">DEFAULT_EMPTY_TRANS_SYMBOL</span><span class="p">,</span>
        <span class="n">initial_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">final_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_observation_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">can_have_accepting_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">merge_sinks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">smoothing_amount</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">SMOOTHING_AMOUNT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a map of start state label and symbol to destination state&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_key_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;mapping between all outgoing transitions and the</span>
<span class="sd">        networkx adjacency dictionary keys.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span> <span class="o">=</span> <span class="n">symbol_display_map</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bidirectional mapping from symbol labels to an int index in</span>
<span class="sd">           transition dists.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_size</span> <span class="o">=</span> <span class="n">alphabet_size</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of symbols in automaton alphabet&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span> <span class="o">=</span> <span class="n">num_states</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of states in automaton state space&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span> <span class="o">=</span> <span class="n">num_obs</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of state observations in TS obs. space&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span> <span class="o">=</span> <span class="n">final_transition_sym</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;representation of the termination symbol&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">empty_transition_sym</span> <span class="o">=</span> <span class="n">empty_transition_sym</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;symbol to use as the empty (a.k.a. lambda) symbol&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span> <span class="o">=</span> <span class="n">start_state</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;unique start state string label of automaton&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span> <span class="o">=</span> <span class="n">is_stochastic</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;whether symbol probabilities are given for string generation&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_use_smoothing</span> <span class="o">=</span> <span class="n">smooth_transitions</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;whether or not to smooth the input sym. transition distributions&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_amount</span> <span class="o">=</span> <span class="n">smoothing_amount</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;probability mass to re-assign to unseen symbols at each node&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span> <span class="o">=</span> <span class="n">is_sampleable</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;transitions will have pre-computed, well-formed distributions&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_normalized</span> <span class="o">=</span> <span class="n">is_normalized</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;ill-defined transition distributions are normalized to be proper</span>
<span class="sd">           probability distributions over outgoing transitions&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set of all symbols used by the automaton&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set of all states in the automaton&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;the set of all possible state output symbols (observations)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;whether or not there is a unique state dest. under each symbol.</span>
<span class="sd">           Defaults to true and is falsified later during initialization.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transition_matrices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a dict (keyed on symbol) of (num_states x num_states)</span>
<span class="sd">           probabilistic transition matrix</span>
<span class="sd">           (NOT always a proper stochastic mat)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span> <span class="o">=</span> <span class="n">bidict</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a mapping from node label to it&#39;s index in the vectorized</span>
<span class="sd">           representation of the automaton&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state_distribution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a (1 x num_states) ndarray containing the pmf for the initial</span>
<span class="sd">           starting state. For most machines, this simply the indicator</span>
<span class="sd">           function with a one at the index of the state&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_final_state_distribution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a (num_states x 1) ndarray containing the pmf for terminating</span>
<span class="sd">           at each state&#39;s index.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_automata_display_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">automata_data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">automata_display_data_dir_name</span>
        <span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_automata_display_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;the base directory for all output data for the automaton&quot;&quot;&quot;</span>

        <span class="c1"># need to start with a fully initialized networkx digraph</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_node_edge_properties</span><span class="p">(</span>
            <span class="n">state_observation_key</span><span class="o">=</span><span class="n">state_observation_key</span><span class="p">,</span>
            <span class="n">final_weight_key</span><span class="o">=</span><span class="n">final_weight_key</span><span class="p">,</span>
            <span class="n">initial_weight_key</span><span class="o">=</span><span class="n">initial_weight_key</span><span class="p">,</span>
            <span class="n">can_have_accepting_nodes</span><span class="o">=</span><span class="n">can_have_accepting_nodes</span><span class="p">,</span>
            <span class="n">edge_weight_key</span><span class="o">=</span><span class="n">edge_weight_key</span><span class="p">,</span>
            <span class="n">merge_sinks</span><span class="o">=</span><span class="n">merge_sinks</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Automaton.disp_edges">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.disp_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">disp_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints each edge in the graph in an edge-list tuple format</span>

<span class="sd">        :param      graph:  The graph to access. Default = None =&gt; use instance</span>
<span class="sd">        :type       graph:  {None, nx.MultiDiGraph}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">edge_number</span><span class="p">,</span> <span class="n">edge_data</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edge_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Automaton.disp_nodes">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.disp_nodes">[docs]</a>
    <span class="k">def</span> <span class="nf">disp_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints each node&#39;s data view</span>

<span class="sd">        :param      graph:  The graph to access. Default = None =&gt; use instance</span>
<span class="sd">        :type       graph:  {None, nx.MultiDiGraph}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="Automaton.draw">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.draw">[docs]</a>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">should_display</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">img_format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draws (can save) the automaton structure in a way compatible with a</span>
<span class="sd">        jupyter / IPython notebook</span>

<span class="sd">        :param      filename:  The filename to save the automaton image</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pydot_representation</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="n">fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_automata_display_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">img_format</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">fpath</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">should_display</span><span class="p">:</span>
                <span class="n">display</span><span class="p">(</span><span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dot_string</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">should_display</span><span class="p">:</span>
                <span class="n">display</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">dot_string</span><span class="p">))</span></div>


<div class="viewcode-block" id="Automaton.plot_node_trans_dist">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.plot_node_trans_dist">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_node_trans_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the transition pmf at the given curr_state / node.</span>

<span class="sd">        :param      curr_state:  state to display its transition distribution</span>
<span class="sd">        :type       curr_state:  Hashable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trans_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;trans_distribution&quot;</span><span class="p">)</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">trans_dist</span><span class="o">.</span><span class="n">xk</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">trans_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">trans_dist</span><span class="o">.</span><span class="n">xk</span><span class="p">),</span> <span class="s2">&quot;ro&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">mec</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trans_dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">trans_dist</span><span class="o">.</span><span class="n">xk</span><span class="p">),</span> <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Automaton.write_traces_to_file">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.write_traces_to_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">write_traces_to_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">traces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbols</span><span class="p">],</span>
        <span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">alphabet_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">base_file_dir</span><span class="p">:</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes trace samples to a file in the abbadingo format for use in</span>
<span class="sd">        grammatical inference tools like flexfringe</span>

<span class="sd">        :param      traces:         The traces to write to a file</span>
<span class="sd">        :param      file:           The file name to write to. Can be a partial</span>
<span class="sd">                                    path.</span>
<span class="sd">        :param      alphabet_size:  The alphabet size</span>
<span class="sd">        :param      base_file_dir:  Provide this if you want to output the file</span>
<span class="sd">                                    to a different location than</span>
<span class="sd">                                    self.automata_data_dir.</span>

<span class="sd">        :returns:   the absolute filepath to the traces. Will be:</span>
<span class="sd">                    abs_filepath(self.automata_data_dir/file) if base_file_dir</span>
<span class="sd">                    is None. Else, will be: abs_filepath(base_file_dir/file)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the output traces always go to the automaton&#39;s data dir</span>
        <span class="k">if</span> <span class="n">base_file_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_file_dir</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">automata_data_dir</span>

        <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_file_dir</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="n">file_dir</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="n">file_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># make sure the num_samples is an int, so you don&#39;t have to wrap shit</span>
        <span class="c1"># in an &#39;int()&#39; every time...</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># need the header to be:</span>
            <span class="c1"># number_of_training_samples size_of_alphabet</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">alphabet_size</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">:</span>
                <span class="n">trace_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_get_abbadingo_string</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">trace_length</span><span class="p">,</span> <span class="n">is_pos_example</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span></div>


<div class="viewcode-block" id="Automaton.generate_traces">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.generate_traces">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_resamples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">return_whatever_you_got</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force_multicore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeneratedTraceData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generates num_samples random traces from the automaton</span>

<span class="sd">        :param      num_samples:              The number of trace samples to</span>
<span class="sd">                                              generate</span>
<span class="sd">        :param      N:                        maximum length of trace</span>
<span class="sd">        :param      max_resamples:            The maximum number of times to</span>
<span class="sd">                                              resample if if we create a trace</span>
<span class="sd">                                              of length N that still doesn&#39;t</span>
<span class="sd">                                              have a probability &gt; 0 in the</span>
<span class="sd">                                              language</span>
<span class="sd">        :param      return_whatever_you_got:  Whether to return a string with a</span>
<span class="sd">                                              zero probability after all</span>
<span class="sd">                                              resampling attempts are</span>
<span class="sd">                                              exhausted.</span>
<span class="sd">        :param      force_multicore:          whether to force use the threaded</span>
<span class="sd">                                              sampler this is set by default to</span>
<span class="sd">                                              optimize speed, as the threaded</span>
<span class="sd">                                              sampler is slower for smaller</span>
<span class="sd">                                              num_samples. Force this to be</span>
<span class="sd">                                              true if the automaton is slow to</span>
<span class="sd">                                              sample.</span>
<span class="sd">        :param      verbose:                  verbose for joblib.Parallel</span>

<span class="sd">        :returns:   list of sampled traces, list of the associated trace</span>
<span class="sd">                    lengths, list of the associated trace probabilities</span>
<span class="sd">        :rtype:     tuple(list(list(int)), list(int), list(float))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span>

        <span class="c1"># make sure the num_samples is an int, so you don&#39;t have to wrap shit</span>
        <span class="c1"># in an &#39;int()&#39; every time...</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

        <span class="c1"># dont start a parallel job unless it&#39;s a very large one</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num_samples</span> <span class="o">&lt;</span> <span class="mi">500</span> <span class="ow">or</span> <span class="n">NUM_CORES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_multicore</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generate_trace</span><span class="p">(</span>
                    <span class="n">start_state</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">max_resamples</span><span class="p">,</span> <span class="n">return_whatever_you_got</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runner</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">NUM_CORES</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">job</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_trace</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">runner</span><span class="p">(</span>
                <span class="n">job</span><span class="p">(</span><span class="n">start_state</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">max_resamples</span><span class="p">,</span> <span class="n">return_whatever_you_got</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span>
            <span class="p">)</span>

        <span class="n">no_strings_found</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">no_strings_found</span><span class="p">:</span>
            <span class="c1"># remove any None items resulting from failed resampling</span>
            <span class="n">num_failed_samples</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">sample</span><span class="p">,</span> <span class="n">trace_length</span><span class="p">,</span> <span class="n">trace_prob</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="n">trace_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace_length</span><span class="p">)</span>
                    <span class="n">trace_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace_prob</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">num_failed_samples</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">num_failed_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_good_samples</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">-</span> <span class="n">num_failed_samples</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;only sampled </span><span class="si">{</span><span class="n">num_good_samples</span><span class="si">}</span><span class="s2"> non-zero &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;probability strings when </span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> strings &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;were requested. Try increasing &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;the number of resample attempts from </span><span class="si">{</span><span class="n">max_resamples</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;No non-zero probability strings found. Try increasing &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;the number of resample attempts from </span><span class="si">{</span><span class="n">max_resamples</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span></div>


<div class="viewcode-block" id="Automaton.generate_trace">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.generate_trace">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_trace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_resamples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">return_whatever_you_got</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Symbols</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Probability</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a trace w/ prob. &gt; 0 from the automaton from its start_state</span>

<span class="sd">        :param      start_state:              the state label to start sampling</span>
<span class="sd">                                              traces from</span>
<span class="sd">        :param      N:                        maximum length of trace</span>
<span class="sd">        :param      max_resamples:            The maximum number of times to</span>
<span class="sd">                                              resample if if we create a trace</span>
<span class="sd">                                              of length N that still doesn&#39;t</span>
<span class="sd">                                              have a probability &gt; 0 in the</span>
<span class="sd">                                              language</span>
<span class="sd">        :param      return_whatever_you_got:  Whether to return a string with a</span>
<span class="sd">                                              zero probability after all</span>
<span class="sd">                                              resampling attempts are</span>
<span class="sd">                                              exhausted.</span>
<span class="sd">        :param      random_state:             The np.random.RandomState() seed</span>
<span class="sd">                                              parameter for sampling from the</span>
<span class="sd">                                              state transition distribution.</span>
<span class="sd">                                              Defaulting to None causes the</span>
<span class="sd">                                              seed to reset.</span>

<span class="sd">        :returns:   the sequence of symbols emitted, the length of the trace,</span>
<span class="sd">                    the probability of the trace in the language of the</span>
<span class="sd">                    automaton</span>

<span class="sd">        :raises     ValueError:               if you try to generate a trace</span>
<span class="sd">                                              from a non-sampleable automaton</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot generate traces in a non-sampleable automaton&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">curr_state</span> <span class="o">=</span> <span class="n">start_state</span>
        <span class="n">length_of_trace</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">trace_prob</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">num_times_restarted</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">next_symbol</span><span class="p">,</span> <span class="n">trans_probability</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_next_state</span><span class="p">(</span>
            <span class="n">curr_state</span><span class="p">,</span> <span class="n">random_state</span>
        <span class="p">)</span>

        <span class="n">sampled_trace</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_symbol</span><span class="p">]</span>
        <span class="n">curr_state</span> <span class="o">=</span> <span class="n">next_state</span>
        <span class="n">at_terminal_state</span> <span class="o">=</span> <span class="n">next_symbol</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span>
        <span class="n">trace_prob</span> <span class="o">*=</span> <span class="n">trans_probability</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">at_terminal_state</span><span class="p">:</span>
            <span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">next_symbol</span><span class="p">,</span> <span class="n">trans_probability</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_next_state</span><span class="p">(</span>
                <span class="n">curr_state</span><span class="p">,</span> <span class="n">random_state</span>
            <span class="p">)</span>

            <span class="n">curr_state</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="n">trace_prob</span> <span class="o">*=</span> <span class="n">trans_probability</span>

            <span class="k">if</span> <span class="n">next_symbol</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">sampled_trace</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_symbol</span><span class="p">)</span>
            <span class="n">length_of_trace</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># we need to generate a trace with probability &gt; 0, so if we</span>
            <span class="c1"># hit the max trace length limit while sampling, we need to try</span>
            <span class="c1"># sampling a whole new trace again.</span>
            <span class="k">if</span> <span class="n">length_of_trace</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">num_times_restarted</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">num_times_restarted</span> <span class="o">==</span> <span class="n">max_resamples</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;tried resampling a non-zero probability trace &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">max_resamples</span><span class="si">}</span><span class="s2"> times and failed. &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;Try increasing the current max trace length &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> and checking that at least one reachable &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;state has a non-zero final-state probability.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">return_whatever_you_got</span><span class="p">:</span>
                        <span class="n">trace_prob</span> <span class="o">*=</span> <span class="mf">0.0</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_state</span> <span class="o">=</span> <span class="n">start_state</span>
                    <span class="n">length_of_trace</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">trace_prob</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">sampled_trace</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">sampled_trace</span><span class="p">,</span> <span class="n">length_of_trace</span><span class="p">,</span> <span class="n">trace_prob</span></div>


<div class="viewcode-block" id="Automaton.observe">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.observe">[docs]</a>
    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Observation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the given state&#39;s observation symbol</span>

<span class="sd">        :param      curr_state:  The current TS state</span>

<span class="sd">        :returns:   observation symbol emitted at curr_state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Automaton.add_node">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.add_node">[docs]</a>
    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_for_adding</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a single node `node_for_adding` and update node attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node_for_adding : node</span>
<span class="sd">            A node can be any hashable Python object except None.</span>
<span class="sd">        attr : keyword arguments, optional</span>
<span class="sd">            Set or change node attributes using key=value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add_nodes_from</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(1)</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(&#39;Hello&#39;)</span>
<span class="sd">        &gt;&gt;&gt; K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(K3)</span>
<span class="sd">        &gt;&gt;&gt; G.number_of_nodes()</span>
<span class="sd">        3</span>

<span class="sd">        Use keywords set/change node attributes:</span>

<span class="sd">        &gt;&gt;&gt; G.add_node(1, size=10)</span>
<span class="sd">        &gt;&gt;&gt; G.add_node(3, weight=0.4, UTM=(&#39;13S&#39;, 382871, 3972649))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A hashable object is one that can be used as a key in a Python</span>
<span class="sd">        dictionary. This includes strings, numbers, tuples of strings</span>
<span class="sd">        and numbers, etc.</span>

<span class="sd">        On many platforms hashable items also include mutables such as</span>
<span class="sd">        NetworkX Graphs, though one should be careful that the hash</span>
<span class="sd">        doesn&#39;t change on mutables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_for_adding</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>


<div class="viewcode-block" id="Automaton.most_probable_string">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.Automaton.html#specless.automaton.base.Automaton.most_probable_string">[docs]</a>
    <span class="k">def</span> <span class="nf">most_probable_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_string_probability</span><span class="p">:</span> <span class="p">{</span><span class="n">Probability</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_string_length</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_empty_symbol</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">try_to_use_greedy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">backwards_search</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_strings_to_find</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">depth_first</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">add_entropy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MPSReturnData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the bounded, most probable string in the probabilistic</span>
<span class="sd">        language of the automaton.</span>

<span class="sd">        :param      min_string_probability:  The minimum string probability.</span>
<span class="sd">                                             This setting does nothing if</span>
<span class="sd">                                             is_deterministic, as the</span>
<span class="sd">                                             deterministic algorithm is exact.</span>
<span class="sd">                                             (default 0.0)</span>
<span class="sd">        :param      max_string_length:       The maximum string length. This</span>
<span class="sd">                                             setting does nothing if</span>
<span class="sd">                                             is_deterministic, as the</span>
<span class="sd">                                             deterministic algorithm is exact.</span>
<span class="sd">                                             (default 100)</span>
<span class="sd">        :param      allow_empty_symbol:      Indicates if the empty symbol is</span>
<span class="sd">                                             allowed</span>
<span class="sd">        :param      try_to_use_greedy:       whether to try using the MUCH</span>
<span class="sd">                                             faster greedy search algorithm.</span>
<span class="sd">                                             only possible if the automaton has</span>
<span class="sd">                                             deterministic transitions. Only</span>
<span class="sd">                                             set this to False if the automaton</span>
<span class="sd">                                             actually is non-deterministic, as</span>
<span class="sd">                                             the non-deterministic solver is an</span>
<span class="sd">                                             approximation and MUCH slower.</span>
<span class="sd">        :param      backwards_search:        Whether to search from the with</span>
<span class="sd">                                             final probability back to the</span>
<span class="sd">                                             start state. Often will improve</span>
<span class="sd">                                             performance.</span>
<span class="sd">        :param      num_strings_to_find:     The number of viable strings to</span>
<span class="sd">                                             return. Defaults to only return</span>
<span class="sd">                                             the ONE, highest probability</span>
<span class="sd">                                             string encountered thus far in the</span>
<span class="sd">                                             search, which means the algorithm</span>
<span class="sd">                                             is the original BMPS_exact. If &gt;1,</span>
<span class="sd">                                             then the algorithm returns the</span>
<span class="sd">                                             num_strings_to_find most probable,</span>
<span class="sd">                                             viable strings from the search</span>
<span class="sd">                                             heap.</span>
<span class="sd">        :param      depth_first:             Whether to explore the automaton</span>
<span class="sd">                                             using a depth-first search</span>
<span class="sd">                                             pattern. Using a depth-first</span>
<span class="sd">                                             search pattern will be faster for</span>
<span class="sd">                                             very deep, tree-shaped automaton,</span>
<span class="sd">                                             but will not return the absolute</span>
<span class="sd">                                             best symbol sequence for the given</span>
<span class="sd">                                             min_string_prob and</span>
<span class="sd">                                             max_string_length. Only turn on if</span>
<span class="sd">                                             you have a terminal states deep in</span>
<span class="sd">                                             the automaton and you need the</span>
<span class="sd">                                             search to be faster.</span>
<span class="sd">        :param      add_entropy:             Only keeps a new viable string if</span>
<span class="sd">                                             it has a previously unseen</span>
<span class="sd">                                             probability of being generated</span>
<span class="sd">        :param      disable_pbar:            Disable pbar for speeding up the</span>
<span class="sd">                                             computation speed.</span>

<span class="sd">        :returns:   most probable string, probability of producing the most</span>
<span class="sd">                    probable string, num_strings_to_find (their probs., viable</span>
<span class="sd">                    strings) ranked by each string&#39;s probability.</span>

<span class="sd">        :raises     ValueError:              Cannot be computed for</span>
<span class="sd">                                             non-stochastic automaton</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot compute most probable string for a &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;non-stochastic automaton&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># setting default values in case they&#39;re not given</span>
        <span class="k">if</span> <span class="n">min_string_probability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_string_probability</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="n">max_string_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_string_length</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="n">use_BMPS_exact</span> <span class="o">=</span> <span class="n">should_use_BMPS_exact</span><span class="p">(</span>
            <span class="n">num_strings_to_find</span><span class="p">,</span> <span class="n">try_to_use_greedy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span>
        <span class="p">)</span>

        <span class="c1"># if the empty symbol isn&#39;t allowed to be in the MPS, then we should</span>
        <span class="c1"># remove it from all of the viable symbols before we even start the</span>
        <span class="c1"># search</span>
        <span class="n">empty_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_transition_sym</span>
        <span class="k">if</span> <span class="n">allow_empty_symbol</span><span class="p">:</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span> <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="n">empty_symbol</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">use_BMPS_exact</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_BMPS_exact_params</span><span class="p">(</span>
                <span class="n">symbols</span><span class="p">,</span>
                <span class="n">max_string_length</span><span class="p">,</span>
                <span class="n">min_string_probability</span><span class="p">,</span>
                <span class="n">num_strings_to_find</span><span class="p">,</span>
                <span class="n">backwards_search</span><span class="p">,</span>
                <span class="n">allow_empty_symbol</span><span class="p">,</span>
                <span class="n">depth_first</span><span class="p">,</span>
                <span class="n">add_entropy</span><span class="p">,</span>
                <span class="n">disable_pbar</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="n">mps</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">viable_symbols</span><span class="p">)</span> <span class="o">=</span> <span class="n">BMPS_exact</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans_prob_fcn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_trans_probabilities</span>
            <span class="p">(</span><span class="n">mps</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">viable_symbols</span><span class="p">)</span> <span class="o">=</span> <span class="n">SWDFA_MPS</span><span class="p">(</span>
                <span class="n">states</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_labels</span><span class="p">,</span>
                <span class="n">start_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start_state</span><span class="p">,</span>
                <span class="n">F</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_final_state_distribution</span><span class="p">,</span>
                <span class="n">empty_symbol</span><span class="o">=</span><span class="n">empty_symbol</span><span class="p">,</span>
                <span class="n">node_index_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span><span class="p">,</span>
                <span class="n">trans_prob_fcn</span><span class="o">=</span><span class="n">trans_prob_fcn</span><span class="p">,</span>
                <span class="n">transition_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">postprocess_MPS</span><span class="p">(</span>
            <span class="n">mps</span><span class="p">,</span>
            <span class="n">prob</span><span class="p">,</span>
            <span class="n">viable_symbols</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">,</span>
            <span class="n">use_BMPS_exact</span><span class="p">,</span>
            <span class="n">allow_empty_symbol</span><span class="p">,</span>
            <span class="n">backwards_search</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_BMPS_exact_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">symbols</span><span class="p">:</span> <span class="n">Symbols</span><span class="p">,</span>
        <span class="n">max_string_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_string_probability</span><span class="p">:</span> <span class="n">Probability</span><span class="p">,</span>
        <span class="n">num_strings_to_find</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">backwards_search</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">allow_empty_symbol</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">depth_first</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">add_entropy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">disable_pbar</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the BMPS_exact algorithm&#39;s parameters from the current automaton</span>
<span class="sd">        and the algorithm&#39;s desired usage.</span>

<span class="sd">        :param      symbols:                 Candidate symbols for the MPS</span>
<span class="sd">        :param      max_string_length:       The maximum string length.</span>
<span class="sd">        :param      min_string_probability:  The minimum string probability.</span>
<span class="sd">        :param      num_strings_to_find:     The number of viable strings to</span>
<span class="sd">                                             return. Defaults to only return</span>
<span class="sd">                                             the ONE, highest probability</span>
<span class="sd">                                             string encountered thus far in the</span>
<span class="sd">                                             search, which means the algorithm</span>
<span class="sd">                                             is the original BMPS_exact. If &gt;1,</span>
<span class="sd">                                             then the algorithm returns the</span>
<span class="sd">                                             num_strings_to_find most probable,</span>
<span class="sd">                                             viable strings from the search</span>
<span class="sd">                                             heap.</span>
<span class="sd">        :param      backwards_search:        Whether to search from the with</span>
<span class="sd">                                             final probability back to the</span>
<span class="sd">                                             start state. Often will improve</span>
<span class="sd">                                             performance.</span>
<span class="sd">        :param      allow_empty_symbol:      Indicates if the empty symbol is</span>
<span class="sd">                                             allowed</span>
<span class="sd">        :param      depth_first:             Whether to explore the automaton</span>
<span class="sd">                                             using a depth-first search</span>
<span class="sd">                                             pattern. Using a depth-first</span>
<span class="sd">                                             search pattern will be faster for</span>
<span class="sd">                                             very deep, tree-shaped automaton,</span>
<span class="sd">                                             but will not return the absolute</span>
<span class="sd">                                             best symbol sequence for the given</span>
<span class="sd">                                             min_string_prob and</span>
<span class="sd">                                             max_string_length. Only turn on if</span>
<span class="sd">                                             you have a terminal states deep in</span>
<span class="sd">                                             the automaton and you need the</span>
<span class="sd">                                             search to be faster.</span>
<span class="sd">        :param      add_entropy:             Only keeps a new viable string if</span>
<span class="sd">                                             it has a previously unseen</span>
<span class="sd">                                             probability of being generated</span>
<span class="sd">        :param      disable_pbar:            Disable pbar for speeding up the</span>
<span class="sd">                                             computation speed.</span>

<span class="sd">        :returns:   The BMPS_exact parameters dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">empty_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_transition_sym</span>
        <span class="n">empty_sym_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="p">[</span><span class="n">empty_symbol</span><span class="p">]</span>

        <span class="c1"># numba pre-processing</span>
        <span class="n">symbol_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>

        <span class="n">trans_mat_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_matrices</span>
        <span class="n">num_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span>
        <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_states</span><span class="p">,</span> <span class="n">num_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_size</span><span class="p">))</span>

        <span class="n">min_string_prob</span> <span class="o">=</span> <span class="n">min_string_probability</span>

        <span class="k">for</span> <span class="n">sym_idx</span> <span class="ow">in</span> <span class="n">symbol_idxs</span><span class="p">:</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">sym_idx</span><span class="p">)</span>
            <span class="n">trans_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">sym_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_mat_dict</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">backwards_search</span><span class="p">:</span>
            <span class="c1"># we are going to change the search from start to goal, to goal</span>
            <span class="c1"># to start search, as we postulate the product is somewhat</span>
            <span class="c1"># tree-shaped</span>

            <span class="c1"># # this transposes each d x d transition matrix</span>
            <span class="c1"># for sym_idx in symbol_idxs:</span>
            <span class="c1">#     symbol = self._convert_symbol_idxs(sym_idx)</span>
            <span class="c1">#     trans_mat[:, :, sym_idx] = trans_mat_dict[symbol].T</span>
            <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">trans_mat</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_state_distribution</span><span class="o">.</span><span class="n">T</span>
            <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state_distribution</span><span class="o">.</span><span class="n">T</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state_distribution</span>
            <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_final_state_distribution</span>

        <span class="c1"># the empty string is always the first symbols out of both of these</span>
        <span class="c1"># solvers, so if it&#39;s not allowed, we need to generate a string that is</span>
        <span class="c1"># one longer</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_empty_symbol</span><span class="p">:</span>
            <span class="n">max_string_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="n">symbol_idxs</span><span class="p">,</span>
            <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="n">trans_mat</span><span class="p">,</span>
            <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
            <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="n">F</span><span class="p">,</span>
            <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span><span class="p">,</span>
            <span class="s2">&quot;empty_symbol&quot;</span><span class="p">:</span> <span class="n">empty_sym_idx</span><span class="p">,</span>
            <span class="s2">&quot;min_string_prob&quot;</span><span class="p">:</span> <span class="n">min_string_prob</span><span class="p">,</span>
            <span class="s2">&quot;max_string_length&quot;</span><span class="p">:</span> <span class="n">max_string_length</span><span class="p">,</span>
            <span class="s2">&quot;num_strings_to_find&quot;</span><span class="p">:</span> <span class="n">num_strings_to_find</span><span class="p">,</span>
            <span class="s2">&quot;depth_first&quot;</span><span class="p">:</span> <span class="n">depth_first</span><span class="p">,</span>
            <span class="s2">&quot;add_entropy&quot;</span><span class="p">:</span> <span class="n">add_entropy</span><span class="p">,</span>
            <span class="s2">&quot;disable_pbar&quot;</span><span class="p">:</span> <span class="n">disable_pbar</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_choose_next_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pred_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sample&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SampledTransData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Chooses the next state based on curr_state&#39;s transition distribution</span>

<span class="sd">        :param      curr_state:    The current state label</span>
<span class="sd">        :type       curr_state:    Hashable</span>
<span class="sd">        :param      random_state:  The np.random.RandomState() seed parameter</span>
<span class="sd">                                   for sampling from the state transition</span>
<span class="sd">                                   distribution. Defaulting to None causes the</span>
<span class="sd">                                   seed to reset.</span>
<span class="sd">        :param      pred_method:   The method used to choose the next state:</span>
<span class="sd">                                   &#39;sample&#39;:</span>
<span class="sd">                                   sample from the transition</span>
<span class="sd">                                   distribution of the casual state of the</span>
<span class="sd">                                   automaton (the state the machine is left in</span>
<span class="sd">                                   after the sequence of observations). Makes</span>
<span class="sd">                                   non-deterministic predictions.</span>
<span class="sd">                                   &#39;max_prob&#39;:</span>
<span class="sd">                                   like many language models, the selection of</span>
<span class="sd">                                   the next state s_{t+1}, and thus the next</span>
<span class="sd">                                   emitted symbol, conditioned on the set of</span>
<span class="sd">                                   observation symbols O_t = {o_1, ..., o_t}</span>
<span class="sd">                                   is:</span>
<span class="sd">                                   s_{t+1} = argmax_{s&#39;}P(s&#39; | s_t, O_t)</span>
<span class="sd">                                   makes deterministic predictions.</span>
<span class="sd">                                   {&#39;sample&#39;, &#39;max_prob&#39;}</span>

<span class="sd">        :returns:   The next state&#39;s label, the symbol emitted by changing</span>
<span class="sd">                    states, the probability of this transition occurring</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trans_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;trans_distribution&quot;</span><span class="p">)</span>

        <span class="c1"># critical step for use with parallelized libraries. This must be reset</span>
        <span class="c1"># before sampling, as otherwise each of the threads is using the same</span>
        <span class="c1"># seed, and we get lots of duplicated strings</span>
        <span class="n">trans_dist</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># sampling an action (symbol) from the state-action distribution at</span>
        <span class="c1"># curr_state</span>
        <span class="n">next_symbol_idx</span> <span class="o">=</span> <span class="n">trans_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">next_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">next_symbol_idx</span><span class="p">)</span>

        <span class="n">next_state</span><span class="p">,</span> <span class="n">trans_probability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_state</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">next_symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">next_symbol</span><span class="p">,</span> <span class="n">trans_probability</span>

    <span class="k">def</span> <span class="nf">_get_next_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Symbol</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Probability</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the next state given the current state and the &quot;input&quot; symbol.</span>

<span class="sd">        :param      curr_state:  The current state</span>
<span class="sd">        :param      symbol:      The input symbol</span>

<span class="sd">        :returns:   (The next state label, the transition probability)</span>

<span class="sd">        :raises     ValueError:  symbol not in curr_state&#39;s transition function</span>
<span class="sd">        :raises     ValueError:  duplicate symbol in curr_state&#39;s transition</span>
<span class="sd">                                 function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">possible_symbols</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_trans_probabilities</span><span class="p">(</span><span class="n">curr_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_symbols</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;given symbol (</span><span class="si">{}</span><span class="s2">) is not found in the &quot;</span>
                <span class="s2">&quot;curr_state&#39;s (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;transition distribution&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">symbol_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_symbols</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">]</span>
        <span class="n">num_matched_symbols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_matched_symbols</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;given symbol (</span><span class="si">{}</span><span class="s2">) is found multiple times in &quot;</span>
                <span class="s2">&quot;curr_state&#39;s (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;transition distribution&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span><span class="p">:</span>
            <span class="c1"># stored in numpy array, so we just want the float probability</span>
            <span class="c1"># value</span>
            <span class="n">symbol_probability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="n">symbol_idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbol_probability</span> <span class="o">=</span> <span class="n">probabilities</span><span class="p">[</span><span class="n">symbol_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">[(</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">symbol_probability</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_states_edges</span><span class="p">(</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">final_transition_sym</span><span class="p">,</span>
        <span class="n">empty_transition_sym</span><span class="p">,</span>
        <span class="n">is_stochastic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">bidict</span><span class="p">,</span> <span class="n">NXNodeList</span><span class="p">,</span> <span class="n">NXEdgeList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts node and edges data from a manually specified YAML config file</span>
<span class="sd">        to the format needed by:</span>
<span class="sd">            - networkx.add_nodes_from()</span>
<span class="sd">            - networkx.add_edges_from()</span>

<span class="sd">        :param      nodes:                 dict of node objects to be converted</span>
<span class="sd">        :param      edges:                 dictionary adj. list to be converted</span>
<span class="sd">        :param      final_transition_sym:  representation of the termination /</span>
<span class="sd">                                           symbol</span>
<span class="sd">        :param      empty_transition_sym:  representation of the empty</span>
<span class="sd">                                           symbol (a.k.a. lambda)</span>
<span class="sd">        :param      is_stochastic:         the transitions are</span>
<span class="sd">                                           non-probabilistic, so we are going</span>
<span class="sd">                                           to assign a uniform distribution</span>
<span class="sd">                                           over all symbols for the purpose of</span>
<span class="sd">                                           generation</span>

<span class="sd">        :returns:   mapping to display symbols according to their</span>
<span class="sd">                    index in the transition distributions,</span>
<span class="sd">                    properly formated node and edge list containers</span>
<span class="sd">        :rtype:     tuple:</span>
<span class="sd">                    (symbol_display_map - bidirectional mapping of hashable</span>
<span class="sd">                                          symbols, to a unique integer index in</span>
<span class="sd">                                          the symbol map.</span>
<span class="sd">                     nodes - list of tuples:</span>
<span class="sd">                     (node label, node attribute dict),</span>
<span class="sd">                     edges - list of tuples:</span>
<span class="sd">                     (src node label, dest node label, edge attribute dict))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># need to convert the configuration adjacency list given in the config</span>
        <span class="c1"># to an edge list given as a 3-tuple of (source, dest, edgeAttrDict)</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_symbols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># add these symbols first, so we can then later ensure they have the</span>
        <span class="c1"># last two indices</span>
        <span class="n">seen_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">empty_transition_sym</span><span class="p">)</span>
        <span class="n">seen_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_transition_sym</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">dest_edges_data</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># don&#39;t need to add any edges if there is no edge data</span>
            <span class="k">if</span> <span class="n">dest_edges_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">dest_node</span> <span class="ow">in</span> <span class="n">dest_edges_data</span><span class="p">:</span>
                <span class="n">symbols</span> <span class="o">=</span> <span class="n">dest_edges_data</span><span class="p">[</span><span class="n">dest_node</span><span class="p">][</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">is_stochastic</span><span class="p">:</span>
                    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">dest_edges_data</span><span class="p">[</span><span class="n">dest_node</span><span class="p">][</span><span class="s2">&quot;probabilities&quot;</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">symbol_idx</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
                    <span class="n">symbol</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

                    <span class="c1"># need to store new symbols in a map for display</span>
                    <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_symbols</span><span class="p">:</span>
                        <span class="n">seen_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

                    <span class="n">edge_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;symbol&quot;</span><span class="p">:</span> <span class="n">symbol</span><span class="p">}</span>

                    <span class="k">if</span> <span class="n">is_stochastic</span><span class="p">:</span>
                        <span class="n">probability</span> <span class="o">=</span> <span class="n">probabilities</span><span class="p">[</span><span class="n">symbol_idx</span><span class="p">]</span>
                        <span class="n">edge_data</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probability</span>

                    <span class="n">newEdge</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">dest_node</span><span class="p">,</span> <span class="n">edge_data</span><span class="p">)</span>
                    <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newEdge</span><span class="p">)</span>

        <span class="c1"># best convention is to convert dict_items to a list, even though both</span>
        <span class="c1"># are iterable</span>
        <span class="n">converted_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="c1"># ensure that the empty and final symbols always have the last indices</span>
        <span class="c1"># in the display map for use in computations excluding those symbols</span>
        <span class="n">symbol_display_map</span> <span class="o">=</span> <span class="n">bidict</span><span class="p">({})</span>
        <span class="k">for</span> <span class="n">new_sym_idx</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">seen_symbols</span><span class="p">)):</span>
            <span class="n">symbol_display_map</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_sym_idx</span>

        <span class="k">return</span> <span class="n">symbol_display_map</span><span class="p">,</span> <span class="n">converted_nodes</span><span class="p">,</span> <span class="n">edge_list</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_set_state_acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state acceptance property for the given state.</span>

<span class="sd">        Abstract method - must be overridden by subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_initialize_node_edge_properties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">final_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state_observation_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">can_have_accepting_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">edge_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">merge_sinks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">node_data_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the node and edge data properties correctly.</span>

<span class="sd">        :param      initial_weight_key:        key in the automaton&#39;s node data</span>
<span class="sd">                                               corresponding to the weight /</span>
<span class="sd">                                               probability of starting in that</span>
<span class="sd">                                               node. If None, don&#39;t include</span>
<span class="sd">                                               this info in the display of the</span>
<span class="sd">                                               automaton.</span>
<span class="sd">        :param      final_weight_key:          key in the automaton&#39;s node data</span>
<span class="sd">                                               corresponding to the weight /</span>
<span class="sd">                                               probability of ending in that</span>
<span class="sd">                                               node. If None, don&#39;t include</span>
<span class="sd">                                               this info in the display of the</span>
<span class="sd">                                               automaton.</span>
<span class="sd">        :param      state_observation_key:     The key in each node&#39;s data dict</span>
<span class="sd">                                               for state observations. If None,</span>
<span class="sd">                                               don&#39;t include this info in the</span>
<span class="sd">                                               display of the automaton</span>
<span class="sd">        :param      can_have_accepting_nodes:  Indicates if the automata can</span>
<span class="sd">                                               have accepting nodes</span>
<span class="sd">        :param      edge_weight_key:           The key in each edge&#39;s data dict</span>
<span class="sd">                                               for edge weight / prob. If None,</span>
<span class="sd">                                               don&#39;t include this info in the</span>
<span class="sd">                                               display of the automaton</span>
<span class="sd">        :param      merge_sinks:               whether to combine all states</span>
<span class="sd">                                               together that have no outgoing</span>
<span class="sd">                                               edges</span>
<span class="sd">        :param      node_data_args:            keyword arguments to pass to</span>
<span class="sd">                                               _compute_node_data_properties()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">merge_sinks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nx_merge_sinks</span><span class="p">()</span>

        <span class="c1"># do batch computations at initialization, as these shouldn&#39;t</span>
        <span class="c1"># frequently change</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_node_data_properties</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">node_data_args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_node_labels</span><span class="p">(</span>
            <span class="n">initial_weight_key</span><span class="p">,</span>
            <span class="n">final_weight_key</span><span class="p">,</span>
            <span class="n">state_observation_key</span><span class="p">,</span>
            <span class="n">can_have_accepting_nodes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_labels</span><span class="p">(</span><span class="n">edge_weight_key</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># final_transition_sym is just an internal not user-facing symbol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span><span class="p">)</span>

        <span class="c1"># if we used smoothing, these might be larger, so we should expand them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_labels</span><span class="p">)</span>

        <span class="c1"># not all automaton have observations, and this needs to be computed</span>
        <span class="c1"># after self.state_labels exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_labels</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

            <span class="n">N_actual_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N_actual_obs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;given num_obs (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;is different than the actual number of unique &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;observations seen (</span><span class="si">{</span><span class="n">N_actual_obs</span><span class="si">}</span><span class="s2">) in the given &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;graph data. proceeding using &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;self.num_obs = </span><span class="si">{</span><span class="n">N_actual_obs</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span> <span class="o">=</span> <span class="n">N_actual_obs</span>

        <span class="c1"># wait until all node computations are done to make the vectorized rep.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span> <span class="o">=</span> <span class="n">bidict</span><span class="p">(</span>
                <span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)}</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state_distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_initial_state_dist</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_final_state_distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_final_state_dist</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transition_matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_transition_matrices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_node_index_map</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_node_data_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="o">**</span><span class="n">node_data_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base method for calculating the properties for the given node.</span>

<span class="sd">        :param      node:            The node to calculate properties for</span>
<span class="sd">        :param      node_data_args:  keyword arguments to</span>
<span class="sd">                                     _set_state_transition_dist</span>

<span class="sd">        :returns:   The node data properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># acceptance property shouldn&#39;t change after load in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_state_acceptance</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># this edge key map is used to update all of the edges after</span>
        <span class="c1"># distribution setting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_key_map</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_edge_key_map</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

        <span class="c1"># if we compute this once, we can sample from each distribution</span>
        <span class="p">(</span><span class="n">edge_probs</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_symbols</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_state_transition_dist</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">edge_key_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_key_map</span><span class="p">,</span> <span class="o">**</span><span class="n">node_data_args</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_trans_map</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">edge_symbols</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_nx_merge_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        merges all sink states (states with no outgoing edges)</span>

<span class="sd">        DOES not update all internal data structures, just the NX data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Select all nodes with only 2 neighbors</span>
        <span class="n">all_sinks</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_sinks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_global_sink</span> <span class="o">=</span> <span class="n">all_sinks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">all_sinks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sink</span> <span class="o">==</span> <span class="n">new_global_sink</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">curr_pred_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">sink</span><span class="p">))</span>
                <span class="n">job_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">curr_pred_nodes</span><span class="p">:</span>
                    <span class="n">edge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="n">old_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">]</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">new_global_sink</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">]</span>

                    <span class="n">job_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">edge_data</span><span class="p">,</span> <span class="n">old_edges</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">))</span>

                <span class="k">while</span> <span class="ow">not</span> <span class="n">job_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
                    <span class="n">edge_data</span><span class="p">,</span> <span class="n">old_edges</span><span class="p">,</span> <span class="n">new_edges</span> <span class="o">=</span> <span class="n">job_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">old_edges</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">old_edges</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_trans_map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">edge_symbols</span><span class="p">:</span> <span class="n">Symbols</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">:</span> <span class="n">Nodes</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the map of start state label and symbol to destination state</span>

<span class="sd">        :param      curr_state:  The current state label</span>
<span class="sd">        :param      edge_symbols:  The emitted symbols for each edge</span>
<span class="sd">        :param      edge_dests:    The labels of the destination states under</span>
<span class="sd">                                   each symbol at the curr_state</span>

<span class="sd">        :raises     ValueError:  checks for non-deterministic transitions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># creating the mapping from (start state, symbol) -&gt; edge_dests</span>
        <span class="n">disp_edge_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">edge_symbols</span><span class="p">)</span>
        <span class="n">state_symbol_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">([</span><span class="n">curr_state</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">disp_edge_symbols</span><span class="p">),</span> <span class="n">disp_edge_symbols</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">new_trans_map_entries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">state_symbol_keys</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">))</span>

        <span class="c1"># need to merge the newly computed transition map at node to the</span>
        <span class="c1"># existing map</span>
        <span class="c1">#</span>
        <span class="c1"># for a automaton, a given start state and symbol must have a</span>
        <span class="c1"># deterministic transition</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dest_state</span> <span class="ow">in</span> <span class="n">new_trans_map_entries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">start_state</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">:</span>
                <span class="n">new_dest_state</span> <span class="o">=</span> <span class="n">dest_state</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">same_start_state</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span>
                <span class="n">non_deterministic_trans</span> <span class="o">=</span> <span class="n">same_start_state</span> <span class="ow">and</span> <span class="n">new_dest_state</span>
                <span class="k">if</span> <span class="n">non_deterministic_trans</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;duplicate transition from state </span><span class="si">{}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;under symbol </span><span class="si">{}</span><span class="s2"> found - transition must be &quot;</span>
                        <span class="s2">&quot;deterministic&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start_state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">,</span> <span class="o">**</span><span class="n">new_trans_map_entries</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_set_state_transition_dist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">edge_key_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">stochastic</span><span class="p">:</span> <span class="p">{</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">should_complete</span><span class="p">:</span> <span class="p">{</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">violating_state</span><span class="p">:</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">complete</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smooth&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trans_data</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the static state transition distribution for given state.</span>

<span class="sd">        :param      curr_state:       The current state label</span>
<span class="sd">        :param      edge_key_map:     mapping between all outgoing transitions</span>
<span class="sd">                                      and the networkx adjacency dictionary</span>
<span class="sd">                                      keys.</span>
<span class="sd">        :param      stochastic:       the transitions are non-probabilistic, so</span>
<span class="sd">                                      we are going to assign a uniform</span>
<span class="sd">                                      distribution over all symbols for the</span>
<span class="sd">                                      purpose of generation</span>
<span class="sd">        :param      should_complete:  Whether to try transition completion</span>
<span class="sd">        :param      violating_state:  The violating state name</span>
<span class="sd">        :param      complete:         Whether to ensure each transition is</span>
<span class="sd">                                      alphabet-complete.</span>
<span class="sd">                                      {&#39;smooth&#39;, &#39;violate&#39;}</span>
<span class="sd">                                      If &#39;smooth&#39;:</span>
<span class="sd">                                      The completeness processing will alter</span>
<span class="sd">                                      existing transition probabilities</span>
<span class="sd">                                      If &#39;violate&#39;:</span>
<span class="sd">                                      All completed states will be</span>
<span class="sd">                                      sent to the given violating state and the</span>
<span class="sd">                                      existing transition probability</span>
<span class="sd">                                      distributions will NOT be altered.</span>

<span class="sd">        :returns:   The new edge_probs, edge_dests, and edge_symbols added to</span>
<span class="sd">                    the underlying graph</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># using class defaults if not given</span>
        <span class="k">if</span> <span class="n">stochastic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stochastic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span>
        <span class="k">if</span> <span class="n">should_complete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">should_complete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_smoothing</span>

        <span class="c1"># need to convert the hashable symbols to their integer indices for</span>
        <span class="c1"># creating the categorical distribution, which only works with</span>
        <span class="c1"># integers</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">([</span><span class="n">curr_state</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">edge_dests</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">]</span>

        <span class="n">original_edge_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;symbol&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">]</span>
        <span class="n">edge_symbols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">original_edge_symbols</span>
        <span class="p">]</span>
        <span class="n">final_sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span>
        <span class="n">final_trans_symbol_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="p">[</span><span class="n">final_sym</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stochastic</span><span class="p">:</span>
            <span class="c1"># need to add final state probability to trans dist</span>
            <span class="n">edge_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">]</span>
            <span class="n">curr_final_state_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;final_probability&quot;</span><span class="p">)</span>

            <span class="c1"># adding the final-state sequence end transition to the</span>
            <span class="c1"># distribution</span>
            <span class="n">edge_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_final_state_prob</span><span class="p">)</span>
            <span class="n">edge_dests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_state</span><span class="p">)</span>
            <span class="n">edge_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_trans_symbol_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span><span class="p">:</span>
                <span class="c1"># using a uniform distribution to not bias the sampling of</span>
                <span class="c1"># symbols in a deterministic that does not actually have edge</span>
                <span class="c1"># probabilities</span>
                <span class="n">num_symbols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_symbols</span><span class="p">)</span>
                <span class="n">is_final_state</span> <span class="o">=</span> <span class="n">num_symbols</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">is_final_state</span><span class="p">:</span>
                    <span class="n">edge_probs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
                    <span class="n">edge_dests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_state</span><span class="p">)</span>
                    <span class="n">edge_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_trans_symbol_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_probs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_symbols</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">edge_symbols</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_probs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">should_complete</span><span class="p">:</span>
            <span class="p">(</span><span class="n">edge_probs</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_symbols</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_complete_transitions</span><span class="p">(</span>
                <span class="n">curr_state</span><span class="p">,</span>
                <span class="n">edge_probs</span><span class="p">,</span>
                <span class="n">edge_symbols</span><span class="p">,</span>
                <span class="n">edge_dests</span><span class="p">,</span>
                <span class="n">complete</span><span class="p">,</span>
                <span class="n">violating_state</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_normalized</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">edge_probs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">edge_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">edge_probs</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edge_probs</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_probs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">next_sym_dist</span> <span class="o">=</span> <span class="n">rv_discrete</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;transition&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="n">edge_symbols</span><span class="p">,</span> <span class="n">edge_probs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_sym_dist</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Need to update internal data structures with new node / edge data</span>
        <span class="c1"># This could have been changed from things like sample-ability /</span>
        <span class="c1"># stochasticity / completeness corrections.</span>
        <span class="c1">#</span>
        <span class="c1"># completing transitions handles edge updates internally</span>
        <span class="n">new_disp_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">edge_symbols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_edges_from_lists</span><span class="p">(</span>
            <span class="n">curr_state</span><span class="p">,</span> <span class="n">edge_probs</span><span class="p">,</span> <span class="n">new_disp_symbols</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_key_map</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;trans_distribution&quot;</span><span class="p">,</span> <span class="n">next_sym_dist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">edge_probs</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_symbols</span>

    <span class="k">def</span> <span class="nf">_complete_transitions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">edge_probs</span><span class="p">:</span> <span class="n">Probabilities</span><span class="p">,</span>
        <span class="n">edge_symbols</span><span class="p">:</span> <span class="n">Symbols</span><span class="p">,</span>
        <span class="n">edge_dests</span><span class="p">:</span> <span class="n">Nodes</span><span class="p">,</span>
        <span class="n">complete</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;smooth&quot;</span><span class="p">,</span>
        <span class="n">dest_state</span><span class="p">:</span> <span class="p">{</span><span class="n">Node</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trans_data</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes missing transitions from the current state.</span>

<span class="sd">        This function will either:</span>
<span class="sd">        - apply Laplace smoothing to the given categorical state-symbol</span>
<span class="sd">          distributions as unlikely self-loops</span>
<span class="sd">        - add the missing transitions, but give the transitions no mass</span>

<span class="sd">        :param      curr_state:    The current state label for which to smooth</span>
<span class="sd">                                   the distribution</span>
<span class="sd">        :param      edge_probs:    The transition probability values for each</span>
<span class="sd">                                   edge</span>
<span class="sd">        :param      edge_symbols:  The emitted symbols for each edge</span>
<span class="sd">        :param      edge_dests:    The labels of the destination states under</span>
<span class="sd">                                   each symbol at the curr_state</span>
<span class="sd">        :param      complete:      Whether to ensure each transition is</span>
<span class="sd">                                   alphabet-complete.</span>
<span class="sd">                                   {&#39;smooth&#39;, &#39;violate&#39;}</span>
<span class="sd">                                   If &#39;smooth&#39;:</span>
<span class="sd">                                   The completeness processing will alter</span>
<span class="sd">                                   existing transition probabilities</span>
<span class="sd">                                   If &#39;violate&#39;:</span>
<span class="sd">                                   All completed states will be sent to the</span>
<span class="sd">                                   given violating state and the existing</span>
<span class="sd">                                   transition probability distributions will</span>
<span class="sd">                                   NOT be altered.</span>
<span class="sd">        :param      dest_state:    The destination state label for the missing</span>
<span class="sd">                                   transitions.</span>
<span class="sd">                                   (default curr_state)</span>

<span class="sd">        :returns:   The smoothed / completed version of edge_probs, edge_dests,</span>
<span class="sd">                    and edge_symbols</span>

<span class="sd">        :raises     ValueError:    Invalid setting of complete</span>
<span class="sd">        :raises     ValueError:    using &#39;violate&#39; completeness setting, but</span>
<span class="sd">                                   no violating destination state name given</span>
<span class="sd">        :raises     ValueError:    Too-large setting of self._smoothing_amount</span>
<span class="sd">                                   results in laplace smoothing being</span>
<span class="sd">                                   impossible</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># need to check and set completion algorithm</span>
        <span class="n">allowed_completion_algs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;smooth&quot;</span><span class="p">,</span> <span class="s2">&quot;violate&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">complete</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_completion_algs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;given complete setting (</span><span class="si">{</span><span class="n">complete</span><span class="si">}</span><span class="s2">) is not one: &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">allowed_completion_algs</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">complete</span> <span class="o">==</span> <span class="s2">&quot;violate&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dest_state</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;if using the </span><span class="si">{</span><span class="n">complete</span><span class="si">}</span><span class="s2"> setting, you must provide &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;a violating state label to send added transitions to.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">complete</span> <span class="o">==</span> <span class="s2">&quot;smooth&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dest_state</span><span class="p">:</span>
            <span class="n">dest_state</span> <span class="o">=</span> <span class="n">curr_state</span>

        <span class="c1"># setting the amount of probability mass to add to completed</span>
        <span class="c1"># transitions</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="o">==</span> <span class="s2">&quot;smooth&quot;</span><span class="p">:</span>
            <span class="n">prob_to_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_amount</span>
        <span class="k">elif</span> <span class="n">complete</span> <span class="o">==</span> <span class="s2">&quot;violate&quot;</span><span class="p">:</span>
            <span class="c1"># no probability of transition to the violating state,</span>
            <span class="c1"># but the violating state must have a uniform self-transition</span>
            <span class="c1"># distribution over all possible symbols, except for the</span>
            <span class="c1"># &quot;termination&quot; symbol - violating state never terminates.</span>
            <span class="k">if</span> <span class="n">dest_state</span> <span class="o">==</span> <span class="n">curr_state</span><span class="p">:</span>
                <span class="n">prob_to_add</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">alphabet_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prob_to_add</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># here we add in the missing transition probabilities as just very</span>
        <span class="c1"># unlikely self-loops (&#39;smooth&#39;) or 0 probability transitions to the</span>
        <span class="c1"># violating state (&#39;violate&#39;)</span>
        <span class="n">num_of_missing_transitions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_edge_probs</span><span class="p">,</span> <span class="n">new_edge_dests</span><span class="p">,</span> <span class="n">new_edge_symbols</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">all_symbols_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="o">.</span><span class="n">inv</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># actually creating the completed transitions</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">all_symbols_idxs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_symbols</span><span class="p">:</span>
                <span class="n">num_of_missing_transitions</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_edge_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob_to_add</span><span class="p">)</span>
                <span class="n">new_edge_dests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dest_state</span><span class="p">)</span>
                <span class="n">new_edge_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

        <span class="c1"># re-arranging probability mass in the case of needing smoothing</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="o">==</span> <span class="s2">&quot;smooth&quot;</span><span class="p">:</span>
            <span class="n">all_possible_trans</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_probs</span><span class="p">)</span> <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
            <span class="p">]</span>
            <span class="n">num_orig_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_possible_trans</span><span class="p">)</span>

            <span class="c1"># now, we need to remove the smoothed probability mass from the</span>
            <span class="c1"># original transition distribution</span>
            <span class="n">num_added_symbols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edge_symbols</span><span class="p">)</span>
            <span class="n">added_prob_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothing_amount</span> <span class="o">*</span> <span class="n">num_added_symbols</span>
            <span class="n">smoothing_per_orig_trans</span> <span class="o">=</span> <span class="n">added_prob_mass</span> <span class="o">/</span> <span class="n">num_orig_samples</span>

            <span class="k">for</span> <span class="n">trans_idx</span> <span class="ow">in</span> <span class="n">all_possible_trans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge_probs</span><span class="p">[</span><span class="n">trans_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">smoothing_per_orig_trans</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;smoothing failed: transition from state &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">curr_state</span><span class="si">}</span><span class="s2"> to state </span><span class="si">{</span><span class="n">edge_dests</span><span class="p">[</span><span class="n">trans_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;under symbol </span><span class="si">{</span><span class="n">edge_symbols</span><span class="p">[</span><span class="n">trans_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> has &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;too little probability mass &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">edge_probs</span><span class="p">[</span><span class="n">trans_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">) to distribute the &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;desired amount of per-symbol smoothing &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(self._smoothing_amount = </span><span class="si">{</span><span class="n">prob_to_add</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">edge_probs</span><span class="p">[</span><span class="n">trans_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">smoothing_per_orig_trans</span>

        <span class="c1"># combining the new transitions with the smoothed, original</span>
        <span class="c1"># distribution to get the final smoothed distribution</span>
        <span class="n">edge_probs</span> <span class="o">+=</span> <span class="n">new_edge_probs</span>
        <span class="n">edge_dests</span> <span class="o">+=</span> <span class="n">new_edge_dests</span>
        <span class="n">edge_symbols</span> <span class="o">+=</span> <span class="n">new_edge_symbols</span>

        <span class="k">return</span> <span class="n">edge_probs</span><span class="p">,</span> <span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_symbols</span>

    <span class="k">def</span> <span class="nf">_make_initial_state_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index_map</span><span class="p">:</span> <span class="n">bidict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the pmf for the initial state distribution as a numpy array.</span>

<span class="sd">        :param      node_index_map:  The mapping from state label to index in</span>
<span class="sd">                                     vectorized representation of the</span>
<span class="sd">                                     distribution</span>

<span class="sd">        :returns:   (1 x num_states) numpy array containing the probability</span>
<span class="sd">                    distribution of starting at each state&#39;s index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start_state_index</span> <span class="o">=</span> <span class="n">node_index_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_state</span><span class="p">]</span>
        <span class="n">initial_state_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span><span class="p">))</span>
        <span class="n">initial_state_distribution</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_state_index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">initial_state_distribution</span>

    <span class="k">def</span> <span class="nf">_make_final_state_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index_map</span><span class="p">:</span> <span class="n">bidict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the pmf for the final state distribution as a numpy array.</span>

<span class="sd">        :param      node_index_map:  The mapping from state label to index in</span>
<span class="sd">                                     vectorized representation of the</span>
<span class="sd">                                     distribution</span>

<span class="sd">        :returns:   (num_states x 1) numpy array containing the probability</span>
<span class="sd">                    distribution of terminating at each state&#39;s index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">final_state_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="n">node_index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">final_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;final_probability&quot;</span><span class="p">)</span>
            <span class="n">final_state_distribution</span><span class="p">[</span><span class="n">node_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_prob</span>

        <span class="k">return</span> <span class="n">final_state_distribution</span>

    <span class="k">def</span> <span class="nf">_make_transition_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index_map</span><span class="p">:</span> <span class="n">bidict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the mapping from a symbol to the state transition matrix under</span>
<span class="sd">        the given symbol.</span>

<span class="sd">        Not necessarily a proper stochastic matrix, especially in the case of</span>
<span class="sd">        stochastic matrices. Should be properly stochastic if is_sampleable.</span>

<span class="sd">        :param      node_index_map:  The mapping from state label to index in</span>
<span class="sd">                                     vectorized representation of the</span>
<span class="sd">                                     distribution</span>

<span class="sd">        :returns:   mapping from each symbol to the (num_states x num_states)</span>
<span class="sd">                    numpy matrix containing the probability of transitioning</span>
<span class="sd">                    to state i to state j under the given symbol at entry [i,j]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;probability&quot;</span>
        <span class="n">nonedge_trans_prob</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">)</span>
        <span class="n">nodeset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeset</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Ambiguous ordering: `nodelist` contained duplicates.&quot;</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">transition_matrices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_states</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">transition_matrices</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">]</span>
            <span class="n">curr_trans_mat</span> <span class="o">=</span> <span class="n">transition_matrices</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">):</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">node_index_map</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">node_index_map</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="n">e_weight</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">curr_trans_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_weight</span>

            <span class="n">transition_matrices</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_trans_mat</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">transition_matrices</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span> <span class="o">=</span> <span class="n">nonedge_trans_prob</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transition_matrices</span>

    <span class="k">def</span> <span class="nf">_convert_symbol_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer_symbols</span><span class="p">:</span> <span class="p">{</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an iterable container of integer representations of automaton</span>
<span class="sd">        symbols to their readable, user-meaningful form.</span>

<span class="sd">        :param      integer_symbols:  The integer symbol(s) to convert</span>

<span class="sd">        :returns:   a list of displayable automaton symbols corresponding to</span>
<span class="sd">                    the inputted integer symbols</span>

<span class="sd">        :raises     ValueError:       all given symbol indices must be ints</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">display_symbols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># need to do type-checking / polymorphism handling here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integer_symbols</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">integer_symbols</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="o">.</span><span class="n">inv</span><span class="p">[</span><span class="n">integer_symbols</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">integer_symbols</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">integer_symbols</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="o">.</span><span class="n">inv</span><span class="p">[</span><span class="n">integer_symbols</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;symbol index (</span><span class="si">{</span><span class="n">integer_symbols</span><span class="si">}</span><span class="s2">) is not an int&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_ints</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sym</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">integer_symbols</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_ints</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;not all symbol indices (</span><span class="si">{</span><span class="n">integer_symbols</span><span class="si">}</span><span class="s2">) are ints&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">integer_symbol</span> <span class="ow">in</span> <span class="n">integer_symbols</span><span class="p">:</span>
            <span class="n">converted_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol_display_map</span><span class="o">.</span><span class="n">inv</span><span class="p">[</span><span class="n">integer_symbol</span><span class="p">]</span>
            <span class="n">display_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converted_symbol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">display_symbols</span>

    <span class="k">def</span> <span class="nf">_get_pydot_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dot</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        converts the networkx graph to pydot and sets graphviz graph attributes</span>

<span class="sd">        :returns:   The pydot Dot data structure representation.</span>
<span class="sd">        :rtype:     pydot.Dot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="n">to_pydot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_splines</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_nodesep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_sep</span><span class="p">(</span><span class="s2">&quot;+25,25&quot;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">set_ratio</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span> <span class="nf">_build_edge_key_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a mapping between all outgoing transitions and the</span>
<span class="sd">        networkx adjacency dictionary keys.</span>

<span class="sd">        the mapping M maps:</span>

<span class="sd">        (current node, symbol, destination node) -&gt; edge key in current</span>
<span class="sd">                                                    node&#39;s adj dict</span>

<span class="sd">        :param      curr_state:  The node label to build the mapping at</span>

<span class="sd">        :returns:   The edge key map.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trans_to_edge_key_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dest_state</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">curr_state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">edge_key</span><span class="p">,</span> <span class="n">edge_data</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">edge_data</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">],</span> <span class="n">dest_state</span><span class="p">)</span>
                <span class="n">trans_to_edge_key_map</span><span class="p">[</span><span class="n">trans</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_key</span>

        <span class="k">return</span> <span class="n">trans_to_edge_key_map</span>

    <span class="k">def</span> <span class="nf">_get_trans_probabilities</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Symbols</span><span class="p">,</span> <span class="n">Probabilities</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the transition probabilities and associated symbols at the</span>
<span class="sd">        current state.</span>

<span class="sd">        :param      curr_state:  The curr state</span>

<span class="sd">        :returns:   The transition probabilities and associated symbols</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span><span class="p">:</span>
            <span class="n">trans_distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;trans_distribution&quot;</span><span class="p">)</span>
            <span class="n">possible_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_symbol_idxs</span><span class="p">(</span><span class="n">trans_distribution</span><span class="o">.</span><span class="n">xk</span><span class="p">)</span>
            <span class="n">probabilities</span> <span class="o">=</span> <span class="n">trans_distribution</span><span class="o">.</span><span class="n">pk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possible_symbols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">symbol</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">curr_state</span>
            <span class="p">]</span>
            <span class="n">possible_symbols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">curr_state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stochastic</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;probability&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">curr_state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">possible_symbols</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">possible_symbols</span><span class="p">,</span> <span class="n">probabilities</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_abbadingo_string</span><span class="p">(</span>
        <span class="n">trace</span><span class="p">:</span> <span class="n">Symbols</span><span class="p">,</span> <span class="n">trace_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">is_pos_example</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Abbadingo (sigh) formatted string given a trace string and</span>
<span class="sd">        the label for the trace</span>

<span class="sd">        :param      trace:           The trace string to represent in Abbadingo</span>
<span class="sd">        :param      trace_length:    The trace length</span>
<span class="sd">        :param      is_pos_example:  Indicates if the trace is a positive</span>
<span class="sd">                                     example of the pdfa</span>

<span class="sd">        :returns:   The abbadingo formatted string for the given trace</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trace</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">)</span>
        <span class="n">trace_label</span> <span class="o">=</span> <span class="p">{</span><span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">}[</span><span class="n">is_pos_example</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">trace_label</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trace_length</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">trace</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_set_node_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_weight_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">final_weight_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">state_observation_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">can_have_accepting_nodes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets each node&#39;s label property for use in graphviz output</span>

<span class="sd">        :param      initial_weight_key:        key in the automaton&#39;s node data</span>
<span class="sd">                                               corresponding to the weight /</span>
<span class="sd">                                               probability of starting in that</span>
<span class="sd">                                               node. If None, don&#39;t include</span>
<span class="sd">                                               this info in the display of the</span>
<span class="sd">                                               automaton.</span>
<span class="sd">        :param      final_weight_key:          key in the automaton&#39;s node data</span>
<span class="sd">                                               corresponding to the weight /</span>
<span class="sd">                                               probability of ending in that</span>
<span class="sd">                                               node. If None, don&#39;t include</span>
<span class="sd">                                               this info in the display of the</span>
<span class="sd">                                               automaton.</span>
<span class="sd">        :param      state_observation_key:     The state observation key</span>
<span class="sd">        :param      can_have_accepting_nodes:  Indicates if the automata can</span>
<span class="sd">                                               have accepting nodes</span>
<span class="sd">        :param      graph:                     The graph to access.</span>
<span class="sd">                                               Default = None =&gt; use instance</span>
<span class="sd">        :type       graph:                     {None, nx.MultiDiGraph}</span>
<span class="sd">        :type       final_weight_key:          string</span>
<span class="sd">        :type       can_have_accepting_nodes:  boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">label_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">():</span>
            <span class="n">nodel_key</span> <span class="o">=</span> <span class="n">node_name</span>

            <span class="k">if</span> <span class="n">initial_weight_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="n">initial_weight_key</span><span class="p">]</span>
                <span class="n">initial_wt_string</span> <span class="o">=</span> <span class="n">edge_weight_to_string</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                <span class="n">node_name</span> <span class="o">=</span> <span class="n">initial_wt_string</span> <span class="o">+</span> <span class="s2">&quot; : &quot;</span> <span class="o">+</span> <span class="n">node_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_dot_label_string</span> <span class="o">=</span> <span class="n">node_name</span>

            <span class="k">if</span> <span class="n">final_weight_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="n">final_weight_key</span><span class="p">]</span>
                <span class="n">final_wt_string</span> <span class="o">=</span> <span class="n">edge_weight_to_string</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                <span class="n">node_dot_label_string</span> <span class="o">=</span> <span class="n">node_name</span> <span class="o">+</span> <span class="s2">&quot; : &quot;</span> <span class="o">+</span> <span class="n">final_wt_string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_dot_label_string</span> <span class="o">=</span> <span class="n">node_name</span>

            <span class="n">graphviz_node_label</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">node_dot_label_string</span><span class="p">,</span>
                <span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;gray80&quot;</span><span class="p">,</span>
                <span class="s2">&quot;style&quot;</span><span class="p">:</span> <span class="s2">&quot;filled&quot;</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">state_observation_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obs_label</span> <span class="o">=</span> <span class="n">node_obs_to_str</span><span class="p">(</span><span class="n">node_data</span><span class="p">[</span><span class="n">state_observation_key</span><span class="p">])</span>
                <span class="n">external_label</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">obs_label</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
                <span class="n">graphviz_node_label</span><span class="p">[</span><span class="s2">&quot;xlabel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">external_label</span>

            <span class="n">is_start_state</span> <span class="o">=</span> <span class="n">nodel_key</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span>

            <span class="c1"># colors are ranked in increasing importance</span>
            <span class="k">if</span> <span class="s2">&quot;color&quot;</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>

            <span class="k">if</span> <span class="s2">&quot;is_violating&quot;</span> <span class="ow">in</span> <span class="n">node_data</span> <span class="ow">and</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;is_violating&quot;</span><span class="p">]:</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;diamond&quot;</span><span class="p">})</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;tomato1&quot;</span><span class="p">})</span>

            <span class="k">if</span> <span class="s2">&quot;is_accepting&quot;</span> <span class="ow">in</span> <span class="n">node_data</span> <span class="ow">and</span> <span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;is_accepting&quot;</span><span class="p">]:</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;peripheries&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;doubleoctagon&quot;</span><span class="p">})</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;lawngreen&quot;</span><span class="p">})</span>

            <span class="k">if</span> <span class="n">is_start_state</span><span class="p">:</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="s2">&quot;box&quot;</span><span class="p">})</span>
                <span class="n">graphviz_node_label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fillcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;royalblue1&quot;</span><span class="p">})</span>

            <span class="n">label_dict</span><span class="p">[</span><span class="n">nodel_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">graphviz_node_label</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_edge_labels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">edge_weight_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets each edge&#39;s label property for use in graphviz output</span>

<span class="sd">        :param      edge_weight_key:  The edge data&#39;s &quot;weight&quot; key</span>
<span class="sd">        :param      graph:            The graph to access.</span>
<span class="sd">                                      Default = None =&gt; use instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># this needs to be a mapping from edges (node label tuples) to a</span>
        <span class="c1"># dictionary of attributes</span>
        <span class="n">label_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge_weight_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wt_str</span> <span class="o">=</span> <span class="n">edge_weight_to_string</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">edge_weight_key</span><span class="p">])</span>
                <span class="n">edge_label_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">wt_str</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_label_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;symbol&quot;</span><span class="p">])</span>

            <span class="n">new_label_property</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">edge_label_string</span><span class="p">,</span> <span class="s2">&quot;fontcolor&quot;</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">}</span>
            <span class="n">node_identifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="n">label_dict</span><span class="p">[</span><span class="n">node_identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label_property</span>

        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">label_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_node_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">data_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the node&#39;s data_key data from the graph</span>

<span class="sd">        :param      node_label:  The node label</span>
<span class="sd">        :param      data_key:    The desired node data&#39;s key name</span>
<span class="sd">        :param      graph:       The graph to access. Default = None =&gt; use</span>
<span class="sd">                                 instance</span>

<span class="sd">        :returns:   The node data associated with the node_label and data_key</span>
<span class="sd">        :rtype:     type of self.nodes.data()[node_label][data_key]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">node_data</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span> <span class="ow">and</span> <span class="n">data_key</span> <span class="o">==</span> <span class="s2">&quot;trans_distribution&quot;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;automaton is not sampleable and thus does not have &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;transition distributions&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node_data</span><span class="p">[</span><span class="n">node_label</span><span class="p">][</span><span class="n">data_key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_node_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">data_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the node&#39;s data_key data from the graph</span>

<span class="sd">        :param      node_label:  The node label</span>
<span class="sd">        :param      data_key:    The desired node data&#39;s key name</span>
<span class="sd">        :param      data:        The data to associate with data_key</span>
<span class="sd">        :param      graph:       The graph to access.</span>
<span class="sd">                                 Default = None =&gt; use instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">node_data</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>
        <span class="n">node_data</span><span class="p">[</span><span class="n">node_label</span><span class="p">][</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_get_edge_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">src_node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">dest_node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all edge between src and dest&#39;s data dicts from the graph</span>

<span class="sd">        :param      src_node_label:   The edge&#39;s source node edge label</span>
<span class="sd">        :param      dest_node_label:  The edge&#39;s destination node label</span>
<span class="sd">        :param      graph:            The graph to access.</span>
<span class="sd">                                      Default = None =&gt; use instance</span>

<span class="sd">        :returns:   The edge data dict associated with the src and dest labels</span>
<span class="sd">                    and the desired data_key</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">edge_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">src_node_label</span><span class="p">][</span><span class="n">dest_node_label</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">edge_data</span>

    <span class="k">def</span> <span class="nf">_set_edge_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">src_node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">dest_node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the edge&#39;s data_key with given data</span>

<span class="sd">        :param      src_node_label:   The edge&#39;s source node edge label</span>
<span class="sd">        :param      dest_node_label:  The edge&#39;s destination node label</span>
<span class="sd">        :param      data:             The data to associate with data_key</span>
<span class="sd">        :param      graph:            The graph to access.</span>
<span class="sd">                                      Default = None =&gt; use instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">graph</span><span class="p">[</span><span class="n">src_node_label</span><span class="p">][</span><span class="n">dest_node_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_update_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_label</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">new_edge_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]],</span>
        <span class="n">graph</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates / adds any edges to the graph given new edge data at node</span>

<span class="sd">        :example</span>
<span class="sd">        new_edge_data = {dest_node_label: {&#39;sym1&#39;: {&#39;probability&#39;: 0.35},</span>
<span class="sd">                                           &#39;sym2&#39;: {&#39;probability&#39;: 0.65}}}</span>

<span class="sd">        :param      node_label:     The node label</span>
<span class="sd">        :param      new_edge_data:  The labels of the destination states under</span>
<span class="sd">                                    each symbol at the curr_state</span>
<span class="sd">        :param      graph:          The graph to access.</span>
<span class="sd">                                    Default = None =&gt; use instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_label</span><span class="p">:</span> <span class="n">new_edge_data</span><span class="p">}</span>

        <span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">keydict</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">keydict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="n">graph</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_edges_from_lists</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">edge_probs</span><span class="p">:</span> <span class="n">Probabilities</span><span class="p">,</span>
        <span class="n">edge_symbols</span><span class="p">:</span> <span class="n">Symbols</span><span class="p">,</span>
        <span class="n">edge_dests</span><span class="p">:</span> <span class="n">Nodes</span><span class="p">,</span>
        <span class="n">edge_key_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates edge data given lists of new edge attributes</span>

<span class="sd">        :param      curr_state:    The current state label for which to smooth</span>
<span class="sd">                                   the distribution</span>
<span class="sd">        :param      edge_probs:    The transition probability values for each</span>
<span class="sd">                                   edge</span>
<span class="sd">        :param      edge_symbols:  The emitted symbols for each edge</span>
<span class="sd">        :param      edge_dests:    The labels of the destination states under</span>
<span class="sd">                                   each symbol at the curr_state</span>
<span class="sd">        :param      edge_key_map:  mapping between all outgoing</span>
<span class="sd">                                   transitions and the networkx adjacency</span>
<span class="sd">                                   dictionary keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edge_dests</span><span class="p">,</span> <span class="n">edge_symbols</span><span class="p">,</span> <span class="n">edge_probs</span><span class="p">)</span>

        <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dest_state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">dest_state</span><span class="p">)</span>

            <span class="c1"># for some reason, MultiGraph dictionaries can&#39;t check any form of</span>
            <span class="c1"># duplicate edges, so we have to manually check here :(</span>
            <span class="k">if</span> <span class="n">trans</span> <span class="ow">in</span> <span class="n">edge_key_map</span><span class="p">:</span>
                <span class="n">trans_key</span> <span class="o">=</span> <span class="n">edge_key_map</span><span class="p">[</span><span class="n">trans</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">dest_state</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">trans_key</span><span class="p">)</span>

            <span class="c1"># final transitions are handled by the node&#39;s final probability,</span>
            <span class="c1"># so don&#39;t manually add these transitions</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_transition_sym</span><span class="p">:</span>
                <span class="n">edge_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;symbol&quot;</span><span class="p">:</span> <span class="n">symbol</span><span class="p">,</span> <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="n">prob</span><span class="p">}</span>
                <span class="n">new_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr_state</span><span class="p">,</span> <span class="n">dest_state</span><span class="p">,</span> <span class="n">edge_data</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span></div>



<div class="viewcode-block" id="node_obs_to_str">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.node_obs_to_str.html#specless.automaton.base.node_obs_to_str">[docs]</a>
<span class="k">def</span> <span class="nf">node_obs_to_str</span><span class="p">(</span><span class="n">obs</span><span class="p">:</span> <span class="n">Observation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns a node observation label as an appropriately formatted string</span>

<span class="sd">    :param      obs:  The node observation label</span>

<span class="sd">    :returns:   properly formatted observation label string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">obs_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{obs:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">obs_str</span> <span class="o">=</span> <span class="n">obs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;obs (</span><span class="si">{</span><span class="n">obs</span><span class="si">}</span><span class="s2"> of type (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span><span class="si">}</span><span class="s2">) must be of type: int, str)&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">obs_str</span></div>



<div class="viewcode-block" id="edge_weight_to_string">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.base.edge_weight_to_string.html#specless.automaton.base.edge_weight_to_string">[docs]</a>
<span class="k">def</span> <span class="nf">edge_weight_to_string</span><span class="p">(</span><span class="n">weight</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns a numeric edge weight as an appropriately formatted string</span>

<span class="sd">    :param      weight:  The edge weight to convert to string.</span>
<span class="sd">    :type       weight:  int or float</span>

<span class="sd">    :returns:   properly formatted weight string</span>
<span class="sd">    :rtype:     string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">wt_str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{weight:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">wt_str</span> <span class="o">=</span> <span class="s2">&quot;{weight:.</span><span class="si">{digits}</span><span class="s2">f}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">digits</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wt_str</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kandai Watanabe.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>