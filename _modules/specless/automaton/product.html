<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>specless.automaton.product &mdash; specless 0.0.2 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=e3a6060d"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            specless
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/specless.html">specless</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">specless</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">specless.automaton.product</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for specless.automaton.product</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">bidict</span> <span class="kn">import</span> <span class="n">bidict</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">rv_discrete</span>

<span class="c1"># local packages</span>
<span class="kn">from</span> <span class="nn">specless.factory.builder</span> <span class="kn">import</span> <span class="n">Builder</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Automaton</span>
<span class="kn">from</span> <span class="nn">.pdfa</span> <span class="kn">import</span> <span class="n">PDFA</span>
<span class="kn">from</span> <span class="nn">.transition_system</span> <span class="kn">import</span> <span class="n">TransitionSystem</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GeneratedTraceData</span><span class="p">,</span>
    <span class="n">Node</span><span class="p">,</span>
    <span class="n">NXEdgeList</span><span class="p">,</span>
    <span class="n">NXNodeList</span><span class="p">,</span>
    <span class="n">Observation</span><span class="p">,</span>
    <span class="n">Probability</span><span class="p">,</span>
    <span class="n">Symbol</span><span class="p">,</span>
    <span class="n">Symbols</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">MaxHeap</span>

<span class="c1"># define these type defs for method annotation type hints</span>
<span class="n">TS_Trans_Data</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Observation</span><span class="p">]</span>

<span class="n">IS_STOCHASTIC</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">SPEC_VIOLATING_STATE</span> <span class="o">=</span> <span class="s2">&quot;q_v&quot;</span>


<div class="viewcode-block" id="Product">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.Product.html#specless.automaton.product.Product">[docs]</a>
<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">Automaton</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Describes a product automaton between a specification automaton</span>
<span class="sd">    and a dynamics automaton.</span>

<span class="sd">    You can use this class to compose the two automaton together and then find</span>
<span class="sd">    a controller for the dynamical system that satisfies the specification</span>

<span class="sd">        :param      nodes:                          node list as expected by</span>
<span class="sd">                                                    networkx.add_nodes_from()</span>
<span class="sd">                                                    (node label, node attribute</span>
<span class="sd">                                                    dict)</span>
<span class="sd">        :param      edges:                          edge list as expected by</span>
<span class="sd">                                                    networkx.add_edges_from()</span>
<span class="sd">                                                    (src node label, dest node</span>
<span class="sd">                                                    label, edge attribute dict)</span>
<span class="sd">        :param      symbol_display_map:             bidirectional mapping of</span>
<span class="sd">                                                    hashable symbols, to a</span>
<span class="sd">                                                    unique integer index in the</span>
<span class="sd">                                                    symbol map. Needed to</span>
<span class="sd">                                                    translate between the</span>
<span class="sd">                                                    indices in the transition</span>
<span class="sd">                                                    distribution and the</span>
<span class="sd">                                                    hashable representation</span>
<span class="sd">                                                    which is meaningful to the</span>
<span class="sd">                                                    user</span>
<span class="sd">        :param      alphabet_size:                  number of symbols in system</span>
<span class="sd">                                                    alphabet</span>
<span class="sd">        :param      num_states:                     number of states in</span>
<span class="sd">                                                    automaton state space</span>
<span class="sd">        :param      start_state:                    unique start state string</span>
<span class="sd">                                                    label of system</span>
<span class="sd">        :param      num_obs:                        number of observation</span>
<span class="sd">                                                    symbols</span>
<span class="sd">        :param      final_transition_sym:           representation of the</span>
<span class="sd">                                                    termination symbol. If not</span>
<span class="sd">                                                    given, will default to base</span>
<span class="sd">                                                    class default.</span>
<span class="sd">        :param      empty_transition_sym:           representation of the empty</span>
<span class="sd">                                                    symbol (a.k.a. lambda). If</span>
<span class="sd">                                                    not given, will default to</span>
<span class="sd">                                                    base class default.</span>
<span class="sd">        :param      is_normalized:                  whether to renormalize the</span>
<span class="sd">                                                    edge probabilities such</span>
<span class="sd">                                                    that each states has a well</span>
<span class="sd">                                                    defined transition</span>
<span class="sd">                                                    probability distribution.</span>
<span class="sd">                                                    We typically DONT want to</span>
<span class="sd">                                                    modify the probabilities of</span>
<span class="sd">                                                    the product algorithm,</span>
<span class="sd">                                                    except if we would like to</span>
<span class="sd">                                                    be able to easily sample</span>
<span class="sd">                                                    traces</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="n">NXNodeList</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">NXEdgeList</span><span class="p">,</span>
        <span class="n">symbol_display_map</span><span class="p">:</span> <span class="n">bidict</span><span class="p">,</span>
        <span class="n">alphabet_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_states</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">start_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">num_obs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">final_transition_sym</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span>
        <span class="n">empty_transition_sym</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span>
        <span class="n">is_normalized</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Product&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new instance of an Product automaton object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if we normalize the probabilities</span>
        <span class="k">if</span> <span class="n">is_normalized</span><span class="p">:</span>
            <span class="n">is_sampleable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_sampleable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># need to start with a fully initialized automaton</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">edges</span><span class="p">,</span>
            <span class="n">symbol_display_map</span><span class="p">,</span>
            <span class="n">alphabet_size</span><span class="p">,</span>
            <span class="n">num_states</span><span class="p">,</span>
            <span class="n">start_state</span><span class="p">,</span>
            <span class="n">smooth_transitions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">is_stochastic</span><span class="o">=</span><span class="n">IS_STOCHASTIC</span><span class="p">,</span>
            <span class="n">is_sampleable</span><span class="o">=</span><span class="n">is_sampleable</span><span class="p">,</span>
            <span class="n">is_normalized</span><span class="o">=</span><span class="n">is_normalized</span><span class="p">,</span>
            <span class="n">num_obs</span><span class="o">=</span><span class="n">num_obs</span><span class="p">,</span>
            <span class="n">final_transition_sym</span><span class="o">=</span><span class="n">final_transition_sym</span><span class="p">,</span>
            <span class="n">empty_transition_sym</span><span class="o">=</span><span class="n">empty_transition_sym</span><span class="p">,</span>
            <span class="n">final_weight_key</span><span class="o">=</span><span class="s2">&quot;final_probability&quot;</span><span class="p">,</span>
            <span class="n">state_observation_key</span><span class="o">=</span><span class="s2">&quot;observation&quot;</span><span class="p">,</span>
            <span class="n">can_have_accepting_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">edge_weight_key</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Product.compute_strategy">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.Product.html#specless.automaton.product.Product.compute_strategy">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_strategy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_string_probability</span><span class="p">:</span> <span class="p">{</span><span class="n">Probability</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_string_length</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Symbols</span><span class="p">,</span> <span class="n">Probability</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a control strategy for the dynamical system that best</span>
<span class="sd">        matches the language of the specification.</span>

<span class="sd">        :param      min_string_probability:  The minimum string probability</span>
<span class="sd">        :param      max_string_length:       The maximum string length</span>

<span class="sd">        :returns:   The sequence of controls to apply, the probability in the</span>
<span class="sd">                    languge of the specification of generating the output word</span>
<span class="sd">                    of the dynamical system under the control symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># using DFS for BMPS as products are often very deep, tree-like</span>
        <span class="p">(</span><span class="n">controls_symbols</span><span class="p">,</span> <span class="n">obs_prob</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_probable_string</span><span class="p">(</span>
            <span class="n">min_string_probability</span><span class="p">,</span> <span class="n">max_string_length</span><span class="p">,</span> <span class="n">depth_first</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># None -&gt; completely incompatible</span>
        <span class="k">if</span> <span class="n">controls_symbols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;no valid controller possible for given settings of &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;min_string_probability </span><span class="si">{</span><span class="n">min_string_probability</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;max_string_length </span><span class="si">{</span><span class="n">max_string_length</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">controls_symbols</span><span class="p">,</span> <span class="n">obs_prob</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">controls_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;only &quot;initialization&quot; symbol artificially added to &#39;</span>
                <span class="o">+</span> <span class="s2">&quot;the TS found to be most probable controller -&gt; &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;specification and dynamical system are &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;incompatible. Try adjusting &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;min_string_probability </span><span class="si">{</span><span class="n">min_string_probability</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;max_string_length </span><span class="si">{</span><span class="n">max_string_length</span><span class="si">}</span><span class="s2">, or trying a &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;different solver.&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

        <span class="c1"># as seen above, first symbol is a useless / artifical initialization</span>
        <span class="c1"># symbol</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">controls_symbols</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">controls_symbols</span> <span class="o">=</span> <span class="n">controls_symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">controls_symbols</span><span class="p">,</span> <span class="n">obs_prob</span></div>


<div class="viewcode-block" id="Product.generate_traces">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.Product.html#specless.automaton.product.Product.generate_traces">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num_traces_to_find</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_trace_probability</span><span class="p">:</span> <span class="n">Probability</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">complete_samples</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_resamples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">use_greedy_MPS_sampler</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">force_MPS_sampler</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_whatever_you_got</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force_multicore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_progress_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeneratedTraceData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries to generate num_samples random traces from the product.</span>

<span class="sd">        :param      num_samples:              The number of trace samples to</span>
<span class="sd">                                              generate</span>
<span class="sd">        :param      N:                        maximum length of any trace</span>
<span class="sd">        :param      num_traces_to_find:       the number of base random traces</span>
<span class="sd">                                              to find in the automaton when</span>
<span class="sd">                                              using the MPS sampler. This is</span>
<span class="sd">                                              not necessarily the same as</span>
<span class="sd">                                              num_samples, as often the MPS</span>
<span class="sd">                                              sampler is too slow to return</span>
<span class="sd">                                              that many samples. Thus, if you</span>
<span class="sd">                                              allow for it, the MPS samples can</span>
<span class="sd">                                              be resampled to return</span>
<span class="sd">                                              num_samples samples after the MPS</span>
<span class="sd">                                              sampler is done.</span>
<span class="sd">        :param      min_trace_probability:    The minimum trace probability.</span>
<span class="sd">                                              only needed when using the MPS</span>
<span class="sd">                                              sampler. Lowering this will</span>
<span class="sd">                                              result in more random (less</span>
<span class="sd">                                              representative traces), but will</span>
<span class="sd">                                              make the algorithm much faster.</span>
<span class="sd">                                              If set TOO high, you will find no</span>
<span class="sd">                                              traces meeting this requirement.</span>
<span class="sd">                                              (default 0.0)</span>
<span class="sd">        :param      complete_samples:         If enabled, if the underlying</span>
<span class="sd">                                              sampler fails to generate</span>
<span class="sd">                                              num_samples, then any samples it</span>
<span class="sd">                                              does find will be resampled to</span>
<span class="sd">                                              create num_samples samples</span>
<span class="sd">                                              occurring with correct RELATIVE</span>
<span class="sd">                                              frequencies.</span>
<span class="sd">        :param      max_resamples:            The maximum number of times to</span>
<span class="sd">                                              resample if if we create a trace</span>
<span class="sd">                                              of length N that still doesn&#39;t</span>
<span class="sd">                                              have a probability &gt; 0 in the</span>
<span class="sd">                                              language</span>
<span class="sd">        :param      use_greedy_MPS_sampler:   whether to try using the MUCH</span>
<span class="sd">                                              faster greedy search algorithm.</span>
<span class="sd">                                              only possible if the automaton</span>
<span class="sd">                                              has deterministic transitions.</span>
<span class="sd">                                              Only set this to False if the</span>
<span class="sd">                                              automaton actually is</span>
<span class="sd">                                              non-deterministic, as the</span>
<span class="sd">                                              non-deterministic solver is an</span>
<span class="sd">                                              approximation and MUCH slower.</span>
<span class="sd">        :param      force_MPS_sampler:        by default, IF THE PRODUCT HAS</span>
<span class="sd">                                              BEEN NORMALIZED (and thus is</span>
<span class="sd">                                              sampleable), then it will fall</span>
<span class="sd">                                              back on the base class&#39; sampler.</span>
<span class="sd">                                              Not available if the product is</span>
<span class="sd">                                              not is_sampleable. This sampler</span>
<span class="sd">                                              is truly a random MC sampler, and</span>
<span class="sd">                                              thus is appropriate if you want</span>
<span class="sd">                                              to generate traces with more</span>
<span class="sd">                                              randomness than the MPS sampler.</span>
<span class="sd">        :param      return_whatever_you_got:  Whether to return a string with a</span>
<span class="sd">                                              zero probability after all</span>
<span class="sd">                                              resampling attempts are</span>
<span class="sd">                                              exhausted.</span>
<span class="sd">        :param      force_multicore:          whether to force use the threaded</span>
<span class="sd">                                              sampler this is set by default to</span>
<span class="sd">                                              optimize speed, as the threaded</span>
<span class="sd">                                              sampler is slower for smaller</span>
<span class="sd">                                              num_samples. Force this to be</span>
<span class="sd">                                              true if the automaton is slow to</span>
<span class="sd">                                              sample.</span>
<span class="sd">        :param      show_progress_bar:        whether to show a tqdm progress</span>
<span class="sd">                                              bar for each sampled trace. Only</span>
<span class="sd">                                              turn this on if you&#39;re sampling a</span>
<span class="sd">                                              few traces from a very</span>
<span class="sd">                                              expensive-to-sample automaton.</span>

<span class="sd">        :returns:   list of sampled traces, list of the associated trace</span>
<span class="sd">                    lengths, list of the associated trace probabilities</span>
<span class="sd">        :rtype:     tuple(list(list(int)), list(int), list(float))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_greedy_MPS_sampler</span> <span class="ow">and</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Must provide a value for N if not using the &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;use_greedy_MPS_sampler&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sampleable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_MPS_sampler</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">generate_traces</span><span class="p">(</span>
                <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
                <span class="n">max_resamples</span><span class="o">=</span><span class="n">max_resamples</span><span class="p">,</span>
                <span class="n">return_whatever_you_got</span><span class="o">=</span><span class="n">return_whatever_you_got</span><span class="p">,</span>
                <span class="n">force_multicore</span><span class="o">=</span><span class="n">force_multicore</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">controls</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sequence_probs</span> <span class="o">=</span> <span class="n">results</span>
            <span class="k">if</span> <span class="n">controls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to max heap to match MPS sampling returns</span>
                <span class="n">viable_traces</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">prob</span><span class="p">,</span> <span class="n">control</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sequence_probs</span><span class="p">,</span> <span class="n">controls</span><span class="p">):</span>
                    <span class="n">viable_traces</span><span class="o">.</span><span class="n">heappush</span><span class="p">((</span><span class="n">prob</span><span class="p">,</span> <span class="n">control</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">viable_traces</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># making sure that these params were provided if using MPS sampler</span>
            <span class="k">if</span> <span class="n">num_traces_to_find</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_greedy_MPS_sampler</span><span class="p">:</span>
                <span class="n">num_traces_to_find</span> <span class="o">=</span> <span class="n">num_samples</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;No value given for num_traces_to_find. Using &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;default value of num_traces_to_find = num_samples &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2">). This may be too slow for large &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;product automata. Try providing a value of &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;num_traces_to_find less than num_samples and &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;enabling complete_samples&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">min_trace_probability</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_greedy_MPS_sampler</span><span class="p">:</span>
                <span class="n">min_trace_probability</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;No value given for min_trace_probability. Using &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;default value of </span><span class="si">{</span><span class="n">min_trace_probability</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_greedy_MPS_sampler</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">viable_traces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_probable_string</span><span class="p">(</span>
                    <span class="n">try_to_use_greedy</span><span class="o">=</span><span class="n">use_greedy_MPS_sampler</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we want to sample from both the most and least likely traces</span>
                <span class="c1"># to get some diversity for resampling</span>
                <span class="n">N_DFS</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_traces_to_find</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">viable_traces_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_probable_string</span><span class="p">(</span>
                    <span class="n">min_string_probability</span><span class="o">=</span><span class="n">min_trace_probability</span><span class="p">,</span>
                    <span class="n">max_string_length</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
                    <span class="n">num_strings_to_find</span><span class="o">=</span><span class="n">N_DFS</span><span class="p">,</span>
                    <span class="n">try_to_use_greedy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">backwards_search</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">depth_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">add_entropy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">N_BFS</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_traces_to_find</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">viable_traces_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_probable_string</span><span class="p">(</span>
                    <span class="n">min_string_probability</span><span class="o">=</span><span class="n">min_trace_probability</span><span class="p">,</span>
                    <span class="n">max_string_length</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
                    <span class="n">num_strings_to_find</span><span class="o">=</span><span class="n">N_BFS</span><span class="p">,</span>
                    <span class="n">try_to_use_greedy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">backwards_search</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">depth_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">add_entropy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># merge the two heaps</span>
                <span class="n">viable_traces</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">item_1</span> <span class="ow">in</span> <span class="n">viable_traces_min</span><span class="p">:</span>
                    <span class="n">viable_traces</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">item_1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item_2</span> <span class="ow">in</span> <span class="n">viable_traces_max</span><span class="p">:</span>
                    <span class="n">viable_traces</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">item_2</span><span class="p">)</span>

        <span class="c1"># need to post-process the sampled data, as this is a product</span>
        <span class="k">if</span> <span class="n">viable_traces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># resampling the viable traces to ensure we always have num_samples</span>
            <span class="c1"># samples</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_traces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_samples</span> <span class="ow">and</span> <span class="n">complete_samples</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">,</span> <span class="n">symbols</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">viable_traces</span><span class="p">)</span>

                <span class="c1"># need to normalize the probabilities, as we won&#39;t have the</span>
                <span class="c1"># full trace distribution</span>
                <span class="n">normalized_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span> <span class="k">for</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">probs</span><span class="p">]</span>
                <span class="n">trace_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)))</span>

                <span class="n">trace_dist</span> <span class="o">=</span> <span class="n">rv_discrete</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="n">trace_idxs</span><span class="p">,</span> <span class="n">normalized_probs</span><span class="p">))</span>
                <span class="n">sampled_trace_idxs</span> <span class="o">=</span> <span class="n">trace_dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>

                <span class="n">new_traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbols</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sampled_trace_idxs</span><span class="p">]</span>
                <span class="n">new_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">probs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sampled_trace_idxs</span><span class="p">]</span>

                <span class="n">viable_traces</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">prob</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_probs</span><span class="p">,</span> <span class="n">new_traces</span><span class="p">):</span>
                    <span class="n">viable_traces</span><span class="o">.</span><span class="n">heappush</span><span class="p">((</span><span class="n">prob</span><span class="p">,</span> <span class="n">trace</span><span class="p">))</span>

            <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">prob</span><span class="p">,</span> <span class="n">controls</span> <span class="ow">in</span> <span class="n">viable_traces</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">controls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># the first control symbol is always the initialization</span>
                    <span class="c1"># symbol, so we should remove it for general use</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">controls</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                        <span class="n">sample</span> <span class="o">=</span> <span class="n">controls</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sample</span> <span class="o">=</span> <span class="n">controls</span>

                    <span class="n">sample_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">controls</span>
                    <span class="n">sample_length</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">trace_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_length</span><span class="p">)</span>
                <span class="n">trace_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">samples</span><span class="p">,</span> <span class="n">trace_lengths</span><span class="p">,</span> <span class="n">trace_probs</span></div>


<div class="viewcode-block" id="Product.observe">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.Product.html#specless.automaton.product.Product.observe">[docs]</a>
    <span class="k">def</span> <span class="nf">observe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Observation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the given state&#39;s observation symbol</span>

<span class="sd">        :param      curr_state:  The current product state</span>

<span class="sd">        :returns:   observation symbol emitted at curr_state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;observation&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_set_state_acceptance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state acceptance property for the given state.</span>

<span class="sd">        If curr_state&#39;s final_probability == 1.00 then the state is guaranteed</span>
<span class="sd">        to be final</span>

<span class="sd">        :param      curr_state:  The current state&#39;s node label</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_final_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;final_probability&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">curr_final_prob</span> <span class="o">&gt;=</span> <span class="mf">1.00</span><span class="p">:</span>
            <span class="n">state_accepts</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state_accepts</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_node_data</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span> <span class="s2">&quot;is_accepting&quot;</span><span class="p">,</span> <span class="n">state_accepts</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_complete_specification</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">specification</span><span class="p">:</span> <span class="n">PDFA</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PDFA</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        processes the automaton and makes sure each state has a transition for</span>
<span class="sd">        each symbol</span>

<span class="sd">        completed nodes will be sent to &quot;violating&quot;, cyclic state with</span>
<span class="sd">        uniform probability over all symbols, as producing the missing symbols</span>
<span class="sd">        is impossible given the language defined by the specification</span>

<span class="sd">        :param      specification:  The specification to complete</span>

<span class="sd">        :returns:   the completed version of the specification</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first need to define and add the &quot;violating&quot; state to the</span>
        <span class="c1"># specification&#39;s underlying graph</span>
        <span class="n">violating_state</span> <span class="o">=</span> <span class="n">SPEC_VIOLATING_STATE</span>
        <span class="n">violating_state_props</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;final_probability&quot;</span><span class="p">:</span> <span class="mf">0.00</span><span class="p">,</span>
            <span class="s2">&quot;trans_distribution&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;is_accepting&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;is_violating&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">specification</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">violating_state</span><span class="p">,</span> <span class="o">**</span><span class="n">violating_state_props</span><span class="p">)</span>

        <span class="n">specification</span><span class="o">.</span><span class="n">_initialize_node_edge_properties</span><span class="p">(</span>
            <span class="n">final_weight_key</span><span class="o">=</span><span class="s2">&quot;final_probability&quot;</span><span class="p">,</span>
            <span class="n">can_have_accepting_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">edge_weight_key</span><span class="o">=</span><span class="s2">&quot;probability&quot;</span><span class="p">,</span>
            <span class="n">should_complete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">violating_state</span><span class="o">=</span><span class="n">violating_state</span><span class="p">,</span>
            <span class="n">complete</span><span class="o">=</span><span class="s2">&quot;violate&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">specification</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_augment_initial_state</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span> <span class="n">specification</span><span class="p">:</span> <span class="n">PDFA</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TransitionSystem</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an initialization state to the dynamical system to maintain</span>
<span class="sd">        language distributional similarity with the specification</span>

<span class="sd">        :param      dynamical_system:  The dynamical system to augment</span>
<span class="sd">        :param      specification:     The specification to take a product with</span>

<span class="sd">        :returns:   The transition system with a new initialization state added</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">initialization_state</span> <span class="o">=</span> <span class="s2">&quot;x_init&quot;</span>

        <span class="n">spec_empty_symbol</span> <span class="o">=</span> <span class="n">specification</span><span class="o">.</span><span class="n">empty_transition_sym</span>
        <span class="n">initialization_state_props</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;observation&quot;</span><span class="p">:</span> <span class="n">spec_empty_symbol</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">spec_empty_symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">observations</span><span class="p">:</span>
            <span class="n">dynamical_system</span><span class="o">.</span><span class="n">observations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">spec_empty_symbol</span><span class="p">)</span>
            <span class="n">dynamical_system</span><span class="o">.</span><span class="n">num_obs</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">dynamical_system</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">initialization_state</span><span class="p">,</span> <span class="o">**</span><span class="n">initialization_state_props</span><span class="p">)</span>
        <span class="n">old_start_state</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">start_state</span>
        <span class="n">dynamical_system</span><span class="o">.</span><span class="n">start_state</span> <span class="o">=</span> <span class="n">initialization_state</span>

        <span class="c1"># can choose any symbol to be the initialization symbol, doesn&#39;t matter</span>
        <span class="n">initialization_symbol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dynamical_system</span><span class="o">.</span><span class="n">symbols</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">initialization_edge_props</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;symbol&quot;</span><span class="p">:</span> <span class="n">initialization_symbol</span><span class="p">,</span>
            <span class="s2">&quot;probability&quot;</span><span class="p">:</span> <span class="mf">1.00</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">dynamical_system</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
            <span class="n">initialization_state</span><span class="p">,</span> <span class="n">old_start_state</span><span class="p">,</span> <span class="o">**</span><span class="n">initialization_edge_props</span>
        <span class="p">)</span>

        <span class="n">dynamical_system</span><span class="o">.</span><span class="n">_initialize_node_edge_properties</span><span class="p">(</span>
            <span class="n">can_have_accepting_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">state_observation_key</span><span class="o">=</span><span class="s2">&quot;observation&quot;</span><span class="p">,</span>
            <span class="n">should_complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dynamical_system</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_compute_product</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span> <span class="n">specification</span><span class="p">:</span> <span class="n">PDFA</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the product automaton given pre-processed automata</span>

<span class="sd">        :param      dynamical_system:  The dynamical system</span>
<span class="sd">        :param      specification:     The specification</span>

<span class="sd">        :returns:   The initialized product automaton configuration data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># naming to follow written algorithm</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">dynamical_system</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">specification</span>
        <span class="n">Sigma</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">symbols</span>

        <span class="n">x_init</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">start_state</span>
        <span class="n">q_init</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">start_state</span>
        <span class="n">init_prod_state</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_product_state_label</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">q_init</span><span class="p">)</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">search_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="n">search_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">x_init</span><span class="p">,</span> <span class="n">q_init</span><span class="p">))</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">search_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">search_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">Sigma</span><span class="p">:</span>
                <span class="n">dyn_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
                <span class="n">dynamically_compatible</span> <span class="o">=</span> <span class="n">dyn_trans</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">_transition_map</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">dynamically_compatible</span><span class="p">:</span>
                    <span class="n">specification_compatible</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x_prime</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">_transition_map</span><span class="p">[</span><span class="n">dyn_trans</span><span class="p">]</span>
                    <span class="n">o_x_prime</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">x_prime</span><span class="p">)</span>
                    <span class="n">spec_trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">o_x_prime</span><span class="p">)</span>
                    <span class="n">specification_compatible</span> <span class="o">=</span> <span class="n">spec_trans</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">_transition_map</span>

                <span class="k">if</span> <span class="n">dynamically_compatible</span> <span class="ow">and</span> <span class="n">specification_compatible</span><span class="p">:</span>
                    <span class="n">q_prime</span><span class="p">,</span> <span class="n">trans_prob</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">_get_next_state</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">o_x_prime</span><span class="p">)</span>
                    <span class="n">q_final_prob</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="s2">&quot;final_probability&quot;</span><span class="p">)</span>
                    <span class="n">q_prime_final_prob</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">_get_node_data</span><span class="p">(</span><span class="n">q_prime</span><span class="p">,</span> <span class="s2">&quot;final_probability&quot;</span><span class="p">)</span>
                    <span class="n">o_x</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                    <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_add_product_edge</span><span class="p">(</span>
                        <span class="n">T</span><span class="p">,</span>
                        <span class="n">nodes</span><span class="p">,</span>
                        <span class="n">edges</span><span class="p">,</span>
                        <span class="n">x_src</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                        <span class="n">x_dest</span><span class="o">=</span><span class="n">x_prime</span><span class="p">,</span>
                        <span class="n">q_src</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
                        <span class="n">q_dest</span><span class="o">=</span><span class="n">q_prime</span><span class="p">,</span>
                        <span class="n">q_src_final_prob</span><span class="o">=</span><span class="n">q_final_prob</span><span class="p">,</span>
                        <span class="n">q_dest_final_prob</span><span class="o">=</span><span class="n">q_prime_final_prob</span><span class="p">,</span>
                        <span class="n">observation_src</span><span class="o">=</span><span class="n">o_x</span><span class="p">,</span>
                        <span class="n">observation_dest</span><span class="o">=</span><span class="n">o_x_prime</span><span class="p">,</span>
                        <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                        <span class="n">trans_prob</span><span class="o">=</span><span class="n">trans_prob</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">prod_dest_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_prime</span><span class="p">,</span> <span class="n">q_prime</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">prod_dest_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prod_dest_state</span><span class="p">)</span>
                        <span class="n">search_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">prod_dest_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_package_data</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">init_prod_state</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_product_state_label</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">dynamical_system_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">specification_state</span><span class="p">:</span> <span class="n">Node</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the combined product state label</span>

<span class="sd">        :param      dynamical_system_state:  The dynamical system state label</span>
<span class="sd">        :param      specification_state:     The specification state label</span>

<span class="sd">        :returns:   The product state label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dynamical_system_state</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">dynamical_system_state</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dynamical_system_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">specification_state</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">specification_state</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">specification_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dynamical_system_state</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="n">specification_state</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_breakdown_product_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">product_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the dynamical system and specification states from a product state</span>

<span class="sd">        :param      product_state:  The product state label</span>

<span class="sd">        :returns:   dynamical system state label, specification state label</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.+?)(?:,\s*|$)&quot;</span><span class="p">,</span> <span class="n">product_state</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">q</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_product_node</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">q_final_prob</span><span class="p">:</span> <span class="n">Probability</span><span class="p">,</span>
        <span class="n">observation</span><span class="p">:</span> <span class="n">Observation</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a newly identified product state to the nodes dict w/ needed data</span>

<span class="sd">        :param      dynamical_system:  The dynamical system</span>
<span class="sd">        :param      nodes:             dict of nodes to build the product out</span>
<span class="sd">                                       of. must be in the format needed by</span>
<span class="sd">                                       networkx.add_nodes_from()</span>
<span class="sd">        :param      x:                 state label in the dynamical system</span>
<span class="sd">        :param      q:                 state label in the specification</span>
<span class="sd">        :param      q_final_prob:      the probability of terminating at q in</span>
<span class="sd">                                       the specification</span>
<span class="sd">        :param      observation:       The observation emitted by the dynamical</span>
<span class="sd">                                       system / product at the dynamical system</span>
<span class="sd">                                       state (x)</span>

<span class="sd">        :returns:   nodes dict populated with all of the given data, and the</span>
<span class="sd">                    label of the newly added product state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prod_state</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_product_state_label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="n">is_violating</span> <span class="o">=</span> <span class="n">q</span> <span class="o">==</span> <span class="n">SPEC_VIOLATING_STATE</span>

        <span class="k">if</span> <span class="n">prod_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">prod_state_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;final_probability&quot;</span><span class="p">:</span> <span class="n">q_final_prob</span><span class="p">,</span>
                <span class="s2">&quot;trans_distribution&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;is_violating&quot;</span><span class="p">:</span> <span class="n">is_violating</span><span class="p">,</span>
                <span class="s2">&quot;is_accepting&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;observation&quot;</span><span class="p">:</span> <span class="n">observation</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="s2">&quot;color&quot;</span> <span class="ow">in</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="s2">&quot;color&quot;</span><span class="p">]</span>
                <span class="n">prod_state_data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">color</span><span class="p">})</span>

            <span class="n">nodes</span><span class="p">[</span><span class="n">prod_state</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_state_data</span>

        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">prod_state</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_product_edge</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">x_src</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">x_dest</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">q_src</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">q_dest</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
        <span class="n">q_src_final_prob</span><span class="p">:</span> <span class="n">Probability</span><span class="p">,</span>
        <span class="n">q_dest_final_prob</span><span class="p">:</span> <span class="n">Probability</span><span class="p">,</span>
        <span class="n">observation_src</span><span class="p">:</span> <span class="n">Observation</span><span class="p">,</span>
        <span class="n">observation_dest</span><span class="p">:</span> <span class="n">Observation</span><span class="p">,</span>
        <span class="n">sigma</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span>
        <span class="n">trans_prob</span><span class="p">:</span> <span class="n">Probability</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a newly identified product edge to the nodes &amp; edges dicts</span>

<span class="sd">        :param      dynamical_system:   The dynamical system</span>
<span class="sd">        :param      nodes:              dict of nodes to build the product out</span>
<span class="sd">                                        of. Must be in the format needed by</span>
<span class="sd">                                        networkx.add_nodes_from()</span>
<span class="sd">        :param      edges:              dict of edges to build the product out</span>
<span class="sd">                                        of. Must be in the format needed by</span>
<span class="sd">                                        networkx.add_edges_from()</span>
<span class="sd">        :param      x_src:              source product edge&#39;s dynamical system</span>
<span class="sd">                                        state</span>
<span class="sd">        :param      x_dest:             dest. product edge&#39;s dynamical system</span>
<span class="sd">                                        state</span>
<span class="sd">        :param      q_src:              source product edge&#39;s specification</span>
<span class="sd">                                        state</span>
<span class="sd">        :param      q_dest:             dest. product edge&#39;s specification</span>
<span class="sd">                                        state</span>
<span class="sd">        :param      q_src_final_prob:   the probability of terminating at q_src</span>
<span class="sd">                                        in the specification</span>
<span class="sd">        :param      q_dest_final_prob:  the probability of terminating at</span>
<span class="sd">                                        q_dest in the specification</span>
<span class="sd">        :param      observation_src:    The observation emitted by the</span>
<span class="sd">                                        dynamical system / product at the</span>
<span class="sd">                                        source dynamical system state (x_src)</span>
<span class="sd">        :param      observation_dest:   The observation emitted by the</span>
<span class="sd">                                        dynamical system / product at the</span>
<span class="sd">                                        dest. dynamical system state (x_dest)</span>
<span class="sd">        :param      sigma:              dynamical system control input symbol</span>
<span class="sd">                                        enabling the product edge</span>
<span class="sd">        :param      trans_prob:         The product edge&#39;s transition prob.</span>

<span class="sd">        :returns:   nodes dict populated w/ all the given data for src &amp; dest</span>
<span class="sd">                    edges dict populated w/ all the given data,</span>
<span class="sd">                    the label of the newly added source product state,</span>
<span class="sd">                    the label of the newly added product state</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes</span><span class="p">,</span> <span class="n">prod_src</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_add_product_node</span><span class="p">(</span>
            <span class="n">dynamical_system</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">x_src</span><span class="p">,</span> <span class="n">q_src</span><span class="p">,</span> <span class="n">q_src_final_prob</span><span class="p">,</span> <span class="n">observation_src</span>
        <span class="p">)</span>
        <span class="n">nodes</span><span class="p">,</span> <span class="n">prod_dest</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_add_product_node</span><span class="p">(</span>
            <span class="n">dynamical_system</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">x_dest</span><span class="p">,</span> <span class="n">q_dest</span><span class="p">,</span> <span class="n">q_dest_final_prob</span><span class="p">,</span> <span class="n">observation_dest</span>
        <span class="p">)</span>
        <span class="n">prod_edge_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;symbols&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">sigma</span><span class="p">],</span> <span class="s2">&quot;probabilities&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">trans_prob</span><span class="p">]}</span>
        <span class="n">prod_edge</span> <span class="o">=</span> <span class="p">{</span><span class="n">prod_dest</span><span class="p">:</span> <span class="n">prod_edge_data</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">prod_src</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prod_dest</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">prod_src</span><span class="p">]:</span>
                <span class="n">existing_edge_data</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">prod_src</span><span class="p">][</span><span class="n">prod_dest</span><span class="p">]</span>

                <span class="n">existing_edge_data</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">prod_edge_data</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
                <span class="n">new_probs</span> <span class="o">=</span> <span class="n">prod_edge_data</span><span class="p">[</span><span class="s2">&quot;probabilities&quot;</span><span class="p">]</span>
                <span class="n">existing_edge_data</span><span class="p">[</span><span class="s2">&quot;probabilities&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_probs</span><span class="p">)</span>

                <span class="n">edges</span><span class="p">[</span><span class="n">prod_src</span><span class="p">][</span><span class="n">prod_dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing_edge_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[</span><span class="n">prod_src</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">prod_edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">prod_src</span><span class="p">]</span> <span class="o">=</span> <span class="n">prod_edge</span>

        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">prod_src</span><span class="p">,</span> <span class="n">prod_dest</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_package_data</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">init_prod_state</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">config_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">final_sym</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">final_transition_sym</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;final_transition_sym&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_sym</span>
        <span class="n">empty_sym</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">empty_transition_sym</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;empty_transition_sym&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_sym</span>

        <span class="c1"># can directly compute these from the graph data</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">state_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">observations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edge_data</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edge_data</span><span class="p">[</span><span class="s2">&quot;symbols&quot;</span><span class="p">])</span>
                <span class="n">state_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">observation</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;observation&quot;</span><span class="p">]</span>
            <span class="n">observations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">observation</span><span class="p">)</span>

        <span class="n">alphabet_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">num_states</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_labels</span><span class="p">)</span>
        <span class="n">num_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;alphabet_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphabet_size</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;num_states&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_states</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;num_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_obs</span>

        <span class="p">(</span><span class="n">symbol_display_map</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="o">=</span> <span class="n">Automaton</span><span class="o">.</span><span class="n">_convert_states_edges</span><span class="p">(</span>
            <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">final_sym</span><span class="p">,</span> <span class="n">empty_sym</span><span class="p">,</span> <span class="n">is_stochastic</span><span class="o">=</span><span class="n">IS_STOCHASTIC</span>
        <span class="p">)</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;start_state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_prod_state</span>
        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;symbol_display_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol_display_map</span>

        <span class="k">return</span> <span class="n">config_data</span></div>



<div class="viewcode-block" id="ProductBuilder">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.ProductBuilder.html#specless.automaton.product.ProductBuilder">[docs]</a>
<span class="k">class</span> <span class="nc">ProductBuilder</span><span class="p">(</span><span class="n">Builder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the generic automaton builder class for Product objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ProductBuilder&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new instance of the ProductBuilder</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># need to call the super class constructor to gain its properties</span>
        <span class="n">Builder</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># keep these properties so we don&#39;t re-initialize unless underlying</span>
        <span class="c1"># data changes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ProductBuilder.__call__">
<a class="viewcode-back" href="../../../_autosummary/specless.automaton.product.ProductBuilder.html#specless.automaton.product.ProductBuilder.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">graph_data</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">TransitionSystem</span><span class="p">,</span> <span class="n">PDFA</span><span class="p">],</span>
        <span class="n">graph_data_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;existing_objects&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Product</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an initialized Product instance given the graph_data</span>

<span class="sd">        graph_data and graph_data_format must match</span>

<span class="sd">        :param      graph_data:         The graph configuration file name</span>
<span class="sd">        :param      graph_data_format:  The graph data file format.</span>
<span class="sd">                                        {&#39;existing_objects&#39;}</span>
<span class="sd">        :param      kwargs:             The keywords arguments to the specific</span>
<span class="sd">                                        constructors</span>

<span class="sd">        :returns:   instance of an initialized Product object</span>

<span class="sd">        :raises     ValueError:         checks if graph_data and</span>
<span class="sd">                                        graph_data_format have a compatible</span>
<span class="sd">                                        data loader</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">graph_data_format</span> <span class="o">==</span> <span class="s2">&quot;existing_objects&quot;</span><span class="p">:</span>
            <span class="n">sys</span> <span class="o">=</span> <span class="n">graph_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">graph_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_automata</span><span class="p">(</span>
                <span class="n">dynamical_system</span><span class="o">=</span><span class="n">sys</span><span class="p">,</span> <span class="n">specification</span><span class="o">=</span><span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;graph_data_format (</span><span class="si">{}</span><span class="s2">) must be one of: &quot;</span>
                <span class="o">+</span> <span class="s1">&#39;&quot;existing_objects&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span></div>


    <span class="k">def</span> <span class="nf">_from_automata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dynamical_system</span><span class="p">:</span> <span class="n">TransitionSystem</span><span class="p">,</span>
        <span class="n">specification</span><span class="p">:</span> <span class="n">PDFA</span><span class="p">,</span>
        <span class="n">normalize_trans_probabilities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_steps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Product</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of a Product Automaton from existing automata</span>

<span class="sd">        :param      dynamical_system:               The dynamical system</span>
<span class="sd">                                                    automaton instance</span>
<span class="sd">        :param      specification:                  The specification automaton</span>
<span class="sd">                                                    instance</span>
<span class="sd">        :param      normalize_trans_probabilities:  whether to renormalize the</span>
<span class="sd">                                                    edge probabilities such</span>
<span class="sd">                                                    that each states has a well</span>
<span class="sd">                                                    defined transition</span>
<span class="sd">                                                    probability distribution.</span>
<span class="sd">                                                    We typically DONT want to</span>
<span class="sd">                                                    modify the probabilities</span>
<span class="sd">                                                    of the product algorithm,</span>
<span class="sd">                                                    except if we would like</span>
<span class="sd">                                                    to be able to easily sample</span>
<span class="sd">                                                    from the automaton.</span>
<span class="sd">        :param      show_steps:                     draw intermediate steps in</span>
<span class="sd">                                                    the product creation</span>

<span class="sd">        :returns:   instance of an initialized Product automaton object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># don&#39;t want to destroy the automaton when we pre-process them</span>
        <span class="n">internal_dyn_sys</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dynamical_system</span><span class="p">)</span>

        <span class="n">augmented_dyn_sys</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">_augment_initial_state</span><span class="p">(</span>
            <span class="n">internal_dyn_sys</span><span class="p">,</span> <span class="n">specification</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">show_steps</span><span class="p">:</span>
            <span class="n">augmented_dyn_sys</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;augment_initial_state&quot;</span><span class="p">)</span>

        <span class="n">config_data</span> <span class="o">=</span> <span class="n">Product</span><span class="o">.</span><span class="n">_compute_product</span><span class="p">(</span><span class="n">augmented_dyn_sys</span><span class="p">,</span> <span class="n">specification</span><span class="p">)</span>

        <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;is_normalized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_trans_probabilities</span>

        <span class="c1"># saving these so we can just return initialized instances if the</span>
        <span class="c1"># underlying data has not changed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">config_data</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;no compatible edges were found, so the product is empty&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="o">**</span><span class="n">config_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kandai Watanabe.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>